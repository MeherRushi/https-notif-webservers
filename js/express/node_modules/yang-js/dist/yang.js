(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Container - controller of object properties

  // ## Class Container
  var Container,
      Emitter,
      Property,
      cloneDeep,
      delegate,
      kProp,
      hasProp = {}.hasOwnProperty;

  delegate = require('delegates');

  Emitter = require('events').EventEmitter;

  cloneDeep = require('lodash.clonedeep');

  Property = require('./property');

  kProp = Symbol.for('property');

  Container = function () {
    var Container = function (_Property) {
      _inherits(Container, _Property);

      function Container() {
        _classCallCheck(this, Container);

        var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));

        _this.state.children = new Map(); // committed props
        _this.state.pending = new Map(); // uncommitted changed props
        _this.state.delta = void 0;
        _this.state.locked = false;
        _this.state.proxy = {
          has: function has(obj, key) {
            return _this.children.has(key) || key in obj;
          },
          get: function get(obj, key) {
            switch (false) {
              case key !== kProp:
                return _this;
              case key !== '_':
                return _this;
              case key !== 'toJSON':
                return _this.toJSON.bind(_this);
              case !_this.has(key):
                return _this.get(key);
              case !(key in obj):
                return obj[key];
              case key !== 'inspect':
                return _this.toJSON.bind(_this);
              case !(key in _this && typeof _this[key] === 'function'):
                return _this[key].bind(_this);
              case !(typeof key === 'string' && key[0] === '_'):
                return _this[key.substring(1)];
            }
          },
          set: function set(obj, key, value) {
            switch (false) {
              case !_this.has(key):
                return _this._get(key).set(value);
              default:
                return obj[key] = value;
            }
          },
          deleteProperty: function deleteProperty(obj, key) {
            switch (false) {
              case !_this.has(key):
                return _this._get(key).delete();
              case !(key in obj):
                return delete obj[key];
            }
          }
        };
        Object.setPrototypeOf(_this.state, Emitter.prototype);
        return _this;
      }

      _createClass(Container, [{
        key: 'clone',
        value: function clone() {
          var copy, i, len, prop, ref;
          copy = _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'clone', this).call(this, {
            children: new Map(),
            pending: new Map()
          });
          ref = this.props;
          for (i = 0, len = ref.length; i < len; i++) {
            prop = ref[i];
            copy.add(prop.clone({
              parent: copy
            }));
          }
          return copy;
        }

        // ### add (child)

        // This call is used to add a child property to map of children.

      }, {
        key: 'add',
        value: function add(child) {
          this.children.set(child.key, child);
          if (this.value != null) {
            return Object.defineProperty(this.value, child.key, {
              configurable: true,
              enumerable: child.active
            });
          }
        }

        // ### remove (child)

        // This call is used to remove a child property from map of children.

      }, {
        key: 'remove',
        value: function remove(child) {
          this.children.delete(child.key);
          if (this.value != null) {
            return delete this.value[child.key];
          }
        }

        // ### has (key)

      }, {
        key: 'has',
        value: function has(key) {
          return this.children.has(key);
        }

        // ### get (key)

      }, {
        key: '_get',
        value: function _get(key) {
          return this.children.get(key);
        }
      }, {
        key: 'get',
        value: function get(key) {
          switch (false) {
            case !(key != null && this.has(key)):
              return this._get(key).data;
            default:
              return _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'get', this).apply(this, arguments);
          }
        }

        // ### set (obj, opts)

      }, {
        key: 'set',
        value: function set(obj) {
          var _this2 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var subopts;
          // TODO: should we preserve prior changes and restore if super fails?
          this.pending.clear();
          try {
            if (kProp in obj) {
              // TODO: should we also clear Object.defineProperties?
              //try obj = Object.assign {}, obj if kProp of obj
              obj = cloneDeep(obj);
            }
          } catch (error) {}
          _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'set', this).call(this, obj, opts);
          // remove all props not part of pending changes
          subopts = Object.assign({}, opts);
          //prop.delete(subopts) for prop in @props when not @pending.has(prop.key)
          this.props.forEach(function (prop) {
            if (!_this2.pending.has(prop.key)) {
              return prop.delete(subopts);
            }
          });
          return this;
        }

        // ### merge (obj, opts)

        // Enumerate key/value of the passed in `obj` and merge into known child
        // properties.

      }, {
        key: 'merge',
        value: function merge(obj) {
          var _this3 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var deep, k, prop, ref, subopts, v;
          if (opts.origin == null) {
            opts.origin = this;
          }
          if (obj === null) {
            return this.delete(opts);
          }
          if (opts.replace || this.value == null) {
            return this.set(obj, opts);
          }

          // TODO: protect this as a transaction?
          var _opts$deep = opts.deep;
          deep = _opts$deep === undefined ? true : _opts$deep;

          subopts = Object.assign({}, opts, {
            inner: true,
            replace: !deep
          });
          for (k in obj) {
            if (!hasProp.call(obj, k)) continue;
            v = obj[k];
            this.debug(function () {
              return '[merge] looking for ' + k + ' inside ' + _this3.children.size + ' children';
            });
            prop = (ref = this.children.get(k)) != null ? ref : this.in(k);
            if (!(prop != null && !Array.isArray(prop))) {
              continue;
            }
            this.debug(function () {
              return '[merge] applying value to child prop ' + prop.key;
            });
            prop.merge(v, subopts);
          }
          // TODO: we should consider evaluating schema.attrs here before calling update

          return this.update(this, opts);
        }

        // ### update

        // Updates the value to the data model. Called *once* for each node that
        // is part of the change branch.

      }, {
        key: 'update',
        value: function update(value) {
          var _this4 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var prop, ref;
          if (opts.origin == null) {
            opts.origin = this;
          }
          if (value instanceof Property) {
            // handle updating pending map if value is a child prop
            if (value.parent === this) {
              this.pending.set(value.key, value);
              this.debug(function () {
                return '[update] pending.set \'' + value.key + '\' now have ' + _this4.pending.size + ' pending changes';
              });
            }
            if (value !== this) {
              if (opts.inner || opts.origin === this) {
                // return right away if part of update on a higher node
                return this;
              }
              // higher up the tree from change origin and continue
              value = this.value;
            }
          }
          this.debug(function () {
            return '[update] handle ' + _this4.pending.size + ' changed props';
          });
          ref = this.changes;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = ref[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              prop = _step.value;

              this.debug(function () {
                return '[update] child ' + prop.uri + ' changed? ' + prop.changed;
              });
              this.add(prop, opts);
              if (!prop.changed) {
                this.pending.delete(prop.key);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (value === this) {
            // dynamically compute value to be used for storing into @state
            value = this.value;
          }
          if (value === null) {
            // we must clear children here if being deleted before calling super (which calls parent.update)
            this.children.clear();
          }
          _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'update', this).call(this, value, opts);
          this.emit('update', this, opts);
          return this;
        }

        // ### commit (opts)

        // Commits the changes to the data model. Async transaction.
        // Events: commit, change

      }, {
        key: 'lock',
        value: async function lock() {
          var _this5 = this;

          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var randomize;
          randomize = function randomize(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
          };
          if (opts.seq == null) {
            opts.seq = randomize(1000, 9999);
          }
          this.debug('[lock:' + opts.seq + '] acquiring lock... already have it?', opts.lock === this);
          if (opts.lock !== this) {
            while (this.locked) {
              await new Promise(function (resolve) {
                return _this5.once('ready', function () {
                  return resolve(true);
                });
              });
            }
          }
          this.debug('[lock:' + opts.seq + '] acquired and has ' + this.pending.size + ' changes, changed? ' + this.changed);
          if (opts.caller != null) {
            this.debug('[lock:' + opts.seq + '] acquired by ' + opts.caller.uri + ' and locked? ' + opts.caller.locked);
          }
          return _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'lock', this).call(this, opts);
        }
      }, {
        key: 'unlock',
        value: function unlock() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.debug('[unlock:' + opts.seq + '] freeing lock...');
          if (!this.locked) {
            return this;
          }
          _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'unlock', this).call(this, opts);
          this.emit('ready');
          return this;
        }
      }, {
        key: 'commit',
        value: async function commit() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var err, failed, id, ref, ref1, ref2, subopts;
          try {
            await this.lock(opts);
            id = (ref = opts.seq) != null ? ref : 0;
            if (this.changed) {
              subopts = Object.assign({}, opts, {
                caller: this,
                inner: true
              });
              delete subopts.lock;
              // 1. commit all the changed children
              this.debug('[commit:' + id + '] wait to commit all the children...');
              await Promise.all(this.changes.filter(function (p) {
                return !p.locked;
              }).map(function (prop) {
                return prop.commit(subopts);
              }));
              // 2. run the commit binding
              if (!opts.sync && ((ref1 = this.binding) != null ? ref1.commit : void 0) != null) {
                this.debug('[commit:' + id + '] executing commit binding...');
                await this.binding.commit(this.context.with(opts));
              }
            }

            // wait for the parent to commit unless called by parent
            if (opts.origin == null) {
              opts.origin = this;
            }
            if (!opts.inner) {
              subopts = Object.assign({}, opts, {
                caller: this
              });
              this.debug('[commit:' + id + '] wait for parent to commit...');
              await ((ref2 = this.parent) != null ? typeof ref2.commit === "function" ? ref2.commit(subopts) : void 0 : void 0);
            }
            if (!opts.suppress && !opts.inner) {
              this.emit('change', opts.origin, opts.actor);
            }
            if (!opts.inner) {
              this.clean(opts);
            }
          } catch (error) {
            err = error;
            this.debug('[commit:' + id + '] error: ' + err.message);
            failed = true;
            throw this.error(err, 'commit');
          } finally {
            this.debug('[commit:' + id + '] finalizing... successful? ' + !failed);
            if (failed) {
              await this.revert(opts);
            }
            this.debug('[commit:' + id + '] ' + this.pending.size + ' changes, now have ' + this.children.size + ' props, releasing lock!');
            this.unlock(opts);
          }
          return this;
        }
      }, {
        key: 'revert',
        value: async function revert() {
          var _this6 = this;

          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var copy, id, prop, ref, ref1;
          if (!this.changed) {
            return;
          }
          id = (ref = opts.seq) != null ? ref : 0;
          this.debug(function () {
            return '[revert:' + id + '] changing back ' + _this6.pending.size + ' pending changes...';
          });
          // NOTE: save a copy of current data here since reverting changed children may alter @state.value
          copy = this.toJSON();
          ref1 = this.changes;

          // XXX: may want to consider Promise.all here
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = ref1[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              prop = _step2.value;

              if (!(!prop.locked || prop === opts.caller)) {
                continue;
              }
              this.debug('[revert:' + id + '] changing back: ' + prop.key);
              await prop.revert(opts);
              this.add(prop);
            }
            // XXX: need to deal with scenario where child nodes reverting is sufficient?

            // below is hackish but works to make a copy of current value
            // to be used as ctx.prior during revert commit binding call
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          this.state.value = copy;
          await _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'revert', this).call(this, opts);
          return this.debug('[revert:' + id + '] ' + this.children.size + ' remaining props');
        }
      }, {
        key: 'clean',
        value: function clean() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var id, prop, ref;
          if (!this.changed) {
            return;
          }
          // traverse down committed nodes and clean their state
          // console.warn(opts.caller) if opts.caller
          id = opts.seq;
          this.debug('[clean:' + id + '] ' + this.pending.size + ' changes with ' + this.children.size + ' props');
          if (this.state.value == null) {
            this.children.clear();
            this.pending.clear();
          } else {
            ref = this.changes;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = ref[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                prop = _step3.value;

                if (!(!prop.locked || prop === opts.caller)) {
                  continue;
                }
                prop.clean(opts);
                this.pending.delete(prop.key);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
          this.debug('[clean:' + id + '] ' + this.pending.size + ' remaining changes');
          return _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'clean', this).call(this, opts);
        }

        // ### toJSON

        // This call creates a new copy of the current `Property.data`
        // completely detached/unbound to the underlying data schema. It's main
        // utility is to represent the current data state for subsequent
        // serialization/transmission. It accepts optional argument `tag` which
        // when called with `true` will tag the produced object with the current
        // property's `@name`.

      }, {
        key: 'toJSON',
        value: function toJSON(key) {
          var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var obj, prop, props, value;
          props = this.props;
          value = function () {
            var i, len;
            switch (false) {
              case !props.length:
                obj = {};
                for (i = 0, len = props.length; i < len; i++) {
                  prop = props[i];
                  if (!(prop.enumerable && (state || prop.mutable))) {
                    continue;
                  }
                  value = prop.toJSON(false, state);
                  if (value != null) {
                    obj[prop.key] = value;
                  }
                }
                return obj;
              default:
                return this.value;
            }
          }.call(this);
          if (key === true) {
            value = _defineProperty({}, '' + this.name, value);
          }
          return value;
        }

        // ### inspect

      }, {
        key: 'inspect',
        value: function inspect() {
          var output;
          output = _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), 'inspect', this).apply(this, arguments);
          return Object.assign(output, {
            children: this.children.size
          });
        }
      }]);

      return Container;
    }(Property);

    ;

    Container.prototype.logger = require('debug')('yang:container');

    delegate(Container.prototype, 'state').getter('children').getter('pending').getter('locked').getter('delta').method('once').method('on').method('off').method('emit');

    Container.property('props', {
      get: function get() {
        return Array.from(this.children.values());
      }
    });

    Container.property('changed', {
      get: function get() {
        return this.pending.size > 0 || this.state.changed;
      }
    });

    Container.property('changes', {
      get: function get() {
        return Array.from(this.pending.values());
      }
    });

    Container.property('change', {
      get: function get() {
        var obj, prop, ref;
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !(this.changed && this.pending.size):
            obj = {};
            ref = this.changes;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = ref[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                prop = _step4.value;

                obj[prop.key] = prop.change;
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            return obj;
          case !this.changed:
            return this.data;
        }
      }
    });

    Container.property('data', {
      set: function set(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function get() {
        var value;
        value = function () {
          var ref;
          switch (false) {
            case ((ref = this.binding) != null ? ref.get : void 0) == null:
              return this.binding.get(this.context);
            default:
              return this.value;
          }
        }.call(this);
        if (!(value instanceof Object)) {
          return value;
        }
        return new Proxy(value, this.state.proxy);
      }
    });

    return Container;
  }.call(this);

  module.exports = Container;
}).call(undefined);

},{"./property":14,"debug":25,"delegates":27,"events":28,"lodash.clonedeep":31}],2:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.5.1
(function () {
  // Context - control logic binding context

  //# Context Object
  var debug, delegate, proto;

  debug = require('debug')('yang:context');

  delegate = require('delegates');

  proto = module.exports = {
    use: function use(name) {
      var ref;
      // TODO: below is a bit of a hack...
      return (ref = this.lookup('feature', name)) != null ? ref.binding : void 0;
    },
    with: function _with() {
      var ctx;
      ctx = Object.create(this);

      for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      ctx.opts = Object.assign.apply(Object, [{}, this.opts].concat(options));
      Object.preventExtensions(ctx);
      return ctx;
    },
    at: function at(key) {
      var node;
      node = this.node.in(key);
      if (node == null) {
        throw this.error('unable to access ' + key);
      }
      return node.context.with(this.opts);
    },
    push: async function push(data) {
      var err, opts, ref;
      if ((ref = this.kind) === 'rpc' || ref === 'action') {
        return this.node.do(data, this.opts);
      }
      opts = Object.assign({}, this.opts); // make a copy
      try {
        (await this.node.lock(opts)).merge(data, opts);
      } catch (error) {
        err = error;
        this.node.unlock(opts);
        throw this.error(err);
      }
      try {
        await this.node.commit(opts);
      } catch (error) {
        err = error;
        throw this.error(err);
      }
      return this.node;
    },

    // convenience function for replace (set operation)
    replace: function replace(data) {
      return this.with({
        replace: true
      }).push(data);
    },
    set: function set(data) {
      return this.node.set(data, Object.assign({}, this.opts));
    },
    merge: function merge(data) {
      return this.node.merge(data, Object.assign({}, this.opts));
    },
    commit: function commit() {
      return this.node.commit(Object.assign({}, this.opts));
    },
    revert: function revert() {
      return this.node.revert(Object.assign({}, this.opts));
    },
    after: function after(timeout, max) {
      timeout = parseInt(timeout) || 100;
      max = parseInt(max) || 5000;
      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve(Math.round(Math.min(max, timeout * 1.5)));
        }, timeout);
      });
    },
    logDebug: function logDebug() {
      return this.log.apply(this, ['debug'].concat(Array.prototype.slice.call(arguments)));
    },
    logInfo: function logInfo() {
      return this.log.apply(this, ['info'].concat(Array.prototype.slice.call(arguments)));
    },
    logWarn: function logWarn() {
      return this.log.apply(this, ['warn'].concat(Array.prototype.slice.call(arguments)));
    },
    logError: function logError() {
      return this.log('error', this.error.apply(this, arguments));
    },
    log: function log(topic) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this.root.emit('log', topic, args, this);
    }
  };

  //# Property node delegation
  delegate(proto, 'node').access('data').getter('prior').getter('delta').getter('value').getter('root').getter('parent').getter('schema').getter('uri').getter('name').getter('kind').getter('path').getter('active').getter('attached').getter('changed').getter('changes').getter('change').getter('delta').method('get').method('error').method('locate').method('lookup').method('find').method('inspect').method('toJSON'); // read/write with validations // used for instance-identifier and leafref validations // boolean // Set of changed properties // Object of uncommitted changes // Object of latest change snapshot

  //# Module delegation
  delegate(proto, 'root').method('access');
}).call(undefined);

},{"debug":25,"delegates":27}],3:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Element - cascading element tree

  // ## Class Element
  var Element,
      Emitter,
      _debug,
      delegate,
      kCache,
      kIndex,
      logger,
      hasProp = {}.hasOwnProperty,
      indexOf = [].indexOf;

  _debug = require('debug');

  logger = _debug('yang:element');

  delegate = require('delegates');

  Emitter = require('events').EventEmitter;

  Emitter.defaultMaxListeners = 100;

  kIndex = Symbol.for('element:index');

  kCache = Symbol.for('element:cache');

  Element = function () {
    var Element = function () {
      _createClass(Element, null, [{
        key: 'property',
        value: function property(prop, desc) {
          return Object.defineProperty(this.prototype, prop, desc);
        }
      }, {
        key: 'use',
        value: function use() {
          var _ref,
              _this = this;

          var res;
          res = (_ref = []).concat.apply(_ref, arguments).filter(function (x) {
            return x != null;
          }).map(function (elem) {
            var e, exists;
            exists = Element.prototype.match.call(_this, elem.kind, elem.tag);
            if (exists != null) {
              _this.debug(function () {
                return 'use: using previously loaded \'' + elem.kind + ':' + elem.tag + '\'';
              });
              return exists;
            }
            try {
              return Element.prototype.merge.call(_this, elem);
            } catch (error) {
              e = error;
              throw _this.error('use: unable to merge \'' + elem.kind + ':' + elem.tag + '\'', e);
            }
          });
          switch (false) {
            case !(res.length > 1):
              return res;
            case res.length !== 1:
              return res[0];
            default:
              return void 0;
          }
        }
      }, {
        key: 'debug',
        value: function debug(f) {
          switch (false) {
            case !_debug.enabled(this.logger.namespace):
              switch (false) {
                case typeof f !== 'function':
                  return this.logger.apply(this, [this.uri].concat(_toConsumableArray([].concat(f()))));
                default:
                  return this.logger.apply(this, [this.uri].concat(Array.prototype.slice.call(arguments)));
              }
          }
        }
      }, {
        key: 'error',
        value: function error(err, ctx) {
          if (!(err instanceof Error)) {
            err = new Error(err);
          }
          err.uri = this.uri;
          err.src = this;
          err.ctx = ctx;
          return err;
        }
      }]);

      function Element(kind1, tag1, scope) {
        var _Object$definePropert;

        _classCallCheck(this, Element);

        this.kind = kind1;
        this.tag = tag1;
        if (this.kind == null) {
          throw this.error("must supply 'kind' to create a new Element");
        }
        if (scope != null) {
          this.scope = scope;
        }
        Object.defineProperties(this, (_Object$definePropert = {
          parent: {
            value: null,
            writable: true
          },
          origin: {
            value: null,
            writable: true
          },
          state: {
            value: {},
            writable: true
          }
        }, _defineProperty(_Object$definePropert, kIndex, {
          value: 0,
          writable: true
        }), _defineProperty(_Object$definePropert, 'emitter', {
          value: new Emitter()
        }), _Object$definePropert));
      }

      // ## Instance-level methods

      // ### clone


      _createClass(Element, [{
        key: 'clone',
        value: function clone() {
          var _this2 = this;

          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var copy, origin, relative;
          var _opts$origin = opts.origin;
          origin = _opts$origin === undefined ? this.origin : _opts$origin;
          var _opts$relative = opts.relative;
          relative = _opts$relative === undefined ? true : _opts$relative;

          this.debug(function () {
            return 'cloning ' + _this2.kind + ':' + _this2.tag + ' with ' + _this2.children.length + ' elements';
          });
          copy = new this.constructor(this.kind, this.tag, this.source).extends(this.children.map(function (x) {
            return x.clone(opts);
          }));
          copy.state = Object.create(this.state);
          copy.state.relative = relative;
          copy.origin = origin != null ? origin : this;
          return copy;
        }

        // ### extends (elements...)

        // This is the primary mechanism for defining sub-elements to become part
        // of the element tree

      }, {
        key: 'extends',
        value: function _extends() {
          var _ref2,
              _this3 = this;

          var elems;
          elems = (_ref2 = []).concat.apply(_ref2, arguments).filter(function (x) {
            return x != null && !!x;
          });
          if (!(elems.length > 0)) {
            return this;
          }
          elems.forEach(function (expr) {
            return _this3.merge(expr);
          });
          this.emit.apply(this, ['change'].concat(_toConsumableArray(elems)));
          return this;
        }

        // ### merge (element)

        // This helper method merges a specific Element into current Element
        // while performing `@scope` validations.

      }, {
        key: 'merge',
        value: function merge(elem) {
          var _this4 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var _merge, exists;
          if (!(elem instanceof Element)) {
            throw this.error("cannot merge invalid element into Element", elem);
          }
          elem.parent = this;
          if (this.children != null) {
            elem[kIndex] = this.children.length;
          }
          this[kCache] = null;
          _merge = function _merge(item) {
            var i, j, len, ref, ref1, ref2, x;
            if (!item.node || opts.append || (ref = item.datakey, indexOf.call((ref1 = this.keys) != null ? ref1 : [], ref) < 0)) {
              this.push(item);
              return true;
            } else if (opts.replace === true) {
              ref2 = this;
              for (i = j = 0, len = ref2.length; j < len; i = ++j) {
                x = ref2[i];
                if (!(x.datakey === item.datakey)) {
                  continue;
                }
                this.splice(i, 1, item);
                break;
              }
              return true;
            } else {
              return false;
            }
          };
          if (this.scope == null) {
            if (!this.hasOwnProperty(elem.kind)) {
              this[elem.kind] = elem;
              return elem;
            }
            if (!Array.isArray(this[elem.kind])) {
              exists = this[elem.kind];
              this[elem.kind] = [exists];
              Object.defineProperty(this[elem.kind], 'keys', {
                get: function () {
                  return this.map(function (x) {
                    return x.datakey;
                  });
                }.bind(this[elem.kind])
              });
            }
            if (!_merge.call(this[elem.kind], elem)) {
              throw this.error('constraint violation for \'' + elem.kind + ' ' + elem.datakey + '\' - cannot define more than once');
            }
            return elem;
          }
          if (!(elem.kind in this.scope)) {
            if (elem.scope != null && !elem.source.state.unbound && !this.source.state.unbound) {
              this.debug(function () {
                return _this4.scope;
              });
              throw this.error('scope violation - invalid \'' + elem.kind + '\' extension found');
            } else {
              this.scope[elem.kind] = '*'; // this is hackish...
            }
          }
          switch (this.scope[elem.kind]) {
            case '0..n':
            case '1..n':
            case '*':
              if (!this.hasOwnProperty(elem.kind)) {
                this[elem.kind] = [];
                Object.defineProperty(this[elem.kind], 'keys', {
                  get: function () {
                    return this.map(function (x) {
                      return x.datakey;
                    });
                  }.bind(this[elem.kind])
                });
              }
              if (!Array.isArray(this[elem.kind])) {
                exists = this[elem.kind];
                this[elem.kind] = [exists];
                Object.defineProperty(this[elem.kind], 'keys', {
                  get: function () {
                    return this.map(function (x) {
                      return x.datakey;
                    });
                  }.bind(this[elem.kind])
                });
              }
              if (!_merge.call(this[elem.kind], elem)) {
                throw this.error('constraint violation for \'' + elem.kind + ' ' + elem.datakey + '\' - already defined');
              }
              break;
            case '0..1':
            case '1':
              if (!this.hasOwnProperty(elem.kind)) {
                this[elem.kind] = elem;
              } else if (opts.replace === true) {
                this.debug(function () {
                  return 'replacing pre-existing ' + elem.kind;
                });
                this[elem.kind] = elem;
              } else {
                throw this.error('constraint violation for \'' + elem.kind + '\' - cannot define more than once');
              }
              break;
            default:
              throw this.error('unrecognized scope constraint defined for \'' + elem.kind + '\' with ' + this.scope[elem.kind]);
          }
          return elem;
        }
      }, {
        key: 'removes',
        value: function removes() {
          var _ref3,
              _this5 = this;

          var elems;
          elems = (_ref3 = []).concat.apply(_ref3, arguments).filter(function (x) {
            return x != null && !!x;
          });
          if (!(elems.length > 0)) {
            return this;
          }
          elems.forEach(function (expr) {
            return _this5.remove(expr);
          });
          this.emit.apply(this, ['change'].concat(_toConsumableArray(elems)));
          return this;
        }
      }, {
        key: 'remove',
        value: function remove(elem) {
          var exists;
          if (!(elem instanceof Element)) {
            throw this.error("cannot remove a non-Element from an Element", elem);
          }
          exists = Element.prototype.match.call(this, elem.kind, elem.datakey);
          if (exists == null) {
            return this;
          }
          if (Array.isArray(this[elem.kind])) {
            this[elem.kind] = this[elem.kind].filter(function (x) {
              return x.datakey !== elem.datakey;
            });
            if (!this[elem.kind].length) {
              delete this[elem.kind];
            }
          } else {
            delete this[elem.kind];
          }
          this[kCache] = null;
          return this;
        }

        // ### update (element)

        // This alternative form of [merge](#merge-element) performs conditional
        // merge based on existence check. It is considered *safer* alternative
        // to direct [merge](#merge-element) call.

        // performs conditional merge based on existence

      }, {
        key: 'update',
        value: function update(elem) {
          var exists, j, len, ref, target;
          if (!(elem instanceof Element)) {
            throw this.error("cannot update a non-Element into an Element", elem);
          }
          //@debug => "update with #{elem.kind}/#{elem.tag}"
          exists = function () {
            switch (false) {
              case elem.tag == null:
                return Element.prototype.match.call(this, elem.kind, elem.datakey);
              default:
                return Element.prototype.match.call(this, elem.kind);
            }
          }.call(this);
          if (exists == null) {
            return this.merge(elem);
          }
          ref = elem.children;
          for (j = 0, len = ref.length; j < len; j++) {
            target = ref[j];
            //@debug => "update #{exists.kind} in-place for #{elem.children.length} elements"
            exists.update(target);
          }
          return exists;
        }

        // Looks for matching Elements using kind and tag
        // Direction: up the hierarchy (towards root)

      }, {
        key: 'lookup',
        value: function lookup(kind, tag) {
          var res;
          //@debug => "lookup: #{kind}(#{tag})..."
          res = function () {
            switch (false) {
              case !!(this instanceof Object):
                return void 0;
              case !(this instanceof Element):
                return this.match(kind, tag);
              default:
                return Element.prototype.match.call(this, kind, tag);
            }
          }.call(this);
          if (res == null) {
            res = function () {
              switch (false) {
                case this.origin == null:
                  return Element.prototype.lookup.apply(this.origin, arguments);
                case this.parent == null:
                  return Element.prototype.lookup.apply(this.parent, arguments);
                default:
                  return Element.prototype.match.call(this.constructor, kind, tag);
              }
            }.apply(this, arguments);
          }
          //@debug => "lookup: #{kind}(#{tag}) got result: #{res?}"
          return res;
        }

        // Looks for matching Elements using YPATH notation
        // Direction: down the hierarchy (away from root)

      }, {
        key: 'at',
        value: function at() {
          return this.locate.apply(this, arguments);
        }
      }, {
        key: 'locate',
        value: function locate(ypath) {
          var key, match, ref, rest;
          if (ypath == null) {
            return;
          }
          if (typeof ypath === 'string') {
            this.debug(function () {
              return 'locate: ' + ypath;
            });
            ypath = ypath.replace(/\s/g, '');
            if (/^\//.test(ypath) && this !== this.root) {
              return this.root.locate(ypath);
            }

            var _ypath$split$filter = ypath.split('/').filter(function (e) {
              return !!e;
            });

            var _ypath$split$filter2 = _toArray(_ypath$split$filter);

            key = _ypath$split$filter2[0];
            rest = _ypath$split$filter2.slice(1);
          } else {
            this.debug(function () {
              return 'locate: ' + ypath.join('/');
            });
            var _ypath = ypath;

            var _ypath2 = _toArray(_ypath);

            key = _ypath2[0];
            rest = _ypath2.slice(1);
          }
          if (key == null) {
            return this;
          }
          match = function () {
            switch (false) {
              case key !== '..':
                return this.match(key);
              default:
                return this.match('*', key);
            }
          }.call(this);
          if ((ref = this.scope[key]) === '0..1' || ref === '1') {
            if (match == null) {
              match = this.match(key);
            }
          }
          switch (false) {
            case !(rest.length > 0):
              return match != null ? match.locate(rest) : void 0;
            default:
              return match;
          }
        }

        // Looks for a matching Element(s) in immediate sub-elements

      }, {
        key: 'match',
        value: function match(kind, tag) {
          var elem, j, len, match;
          if (!(kind != null && this[kind] != null)) {
            return;
          }
          if (tag == null) {
            return this[kind];
          }
          match = this[kind];
          if (!(match instanceof Array)) {
            match = [match];
          }
          if (tag === '*') {
            return match;
          }
          for (j = 0, len = match.length; j < len; j++) {
            elem = match[j];
            if (elem instanceof Element) {
              if (tag === elem.datakey || tag === elem.tag) {
                return elem;
              }
            }
          }
          return void 0;
        }

        // ### toJSON

        // Converts the Element into a JS object

      }, {
        key: 'toJSON',
        value: function toJSON() {
          var _this6 = this;

          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            tag: true,
            extended: false
          };

          var sub;
          //@debug => "converting #{@kind} toJSON with #{@children.length}"
          sub = this.children.filter(function (x) {
            return opts.extended || x.parent === _this6;
          }).reduce(function (a, b) {
            var k, kk, ref, v, vv;
            ref = b.toJSON();
            for (k in ref) {
              v = ref[k];
              if (a[k] instanceof Object) {
                if (v instanceof Object) {
                  for (kk in v) {
                    vv = v[kk];
                    a[k][kk] = vv;
                  }
                }
              } else {
                a[k] = v;
              }
            }
            return a;
          }, {});
          if (opts.tag) {
            return _defineProperty({}, '' + this.kind, function () {
              switch (false) {
                case !(Object.keys(sub).length > 0):
                  if (this.tag != null) {
                    return _defineProperty({}, '' + this.tag, sub);
                  } else {
                    return sub;
                  }
                  break;
                case !(this.tag instanceof Object):
                  return '' + this.tag;
                default:
                  return this.tag;
              }
            }.call(this));
          } else {
            return sub;
          }
        }
      }]);

      return Element;
    }();

    ;

    Element.logger = logger;

    Element.prototype.logger = Element.logger;

    Element.prototype.debug = Element.debug;

    Element.prototype.error = Element.error;

    delegate(Element.prototype, 'emitter').method('emit').method('once').method('on').method('off');

    // ### Computed Properties
    Element.property('datakey', {
      get: function get() {
        var ref;
        return (ref = this.tag) != null ? ref : this.kind;
      }
    });

    Element.property('uri', {
      get: function get() {
        var mark, ref, ref1;
        switch (false) {
          case !(this.parent instanceof Element):
            mark = this.kind;
            if (this.tag != null && ((ref = (ref1 = this.parent.scope) != null ? ref1[this.kind] : void 0) === '0..n' || ref === '1..n' || ref === '*')) {
              mark += '(' + this.tag + ')';
            }
            return this.parent.uri + '/' + mark;
          case this.tag == null:
            return this.kind + '(' + this.tag + ')';
          default:
            return this.kind;
        }
      }
    });

    Element.property('root', {
      get: function get() {
        switch (false) {
          case !(this.parent instanceof Element):
            return this.parent.root;
          case !(this.origin instanceof Element):
            return this.origin.root;
          default:
            return this;
        }
      }
    });

    Element.property('children', {
      get: function get() {
        var elements, k, v;
        if (this[kCache] == null) {
          elements = function () {
            var ref, results;
            ref = this;
            results = [];
            for (k in ref) {
              if (!hasProp.call(ref, k)) continue;
              v = ref[k];
              if (k !== 'parent' && k !== 'origin' && k !== 'tag' && k !== kCache && k !== 'source') {
                results.push(v);
              }
            }
            return results;
          }.call(this).reduce(function (a, b) {
            switch (false) {
              case !(b instanceof Element):
                return a.concat(b);
              case !(b instanceof Array):
                return a.concat(b.filter(function (x) {
                  return x instanceof Element;
                }));
              default:
                return a;
            }
          }, []);
          this[kCache] = elements.sort(function (a, b) {
            return a[kIndex] - b[kIndex];
          });
        }
        return this[kCache];
      }
    });

    Element.property('*', {
      get: function get() {
        return this.children;
      }
    });

    Element.property('..', {
      get: function get() {
        return this.parent;
      }
    });

    return Element;
  }.call(this);

  // ## Export Element Class
  module.exports = Element;
}).call(undefined);

},{"debug":25,"delegates":27,"events":28}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  // expression - evaluable Element
  var Element, Expression, delegate;

  delegate = require('delegates');

  Element = require('./element');

  Expression = function () {
    var Expression = function (_Element) {
      _inherits(Expression, _Element);

      //debug: (f) -> if debug.enabled logger.namespace then logger @uri, [].concat(f())...
      function Expression(kind, tag, source) {
        var _ret;

        _classCallCheck(this, Expression);

        var evaluate, self;

        var _this = _possibleConstructorReturn(this, (Expression.__proto__ || Object.getPrototypeOf(Expression)).call(this, kind, tag));

        _this.source = source;
        evaluate = function evaluate() {
          var _self;

          return (_self = self).eval.apply(_self, arguments);
        };
        self = Object.setPrototypeOf(evaluate, _this);
        Object.defineProperties(self, {
          inspect: {
            value: function value() {
              return this.toJSON();
            }
          }
        });
        delete self.length; // TODO: this may not work for Edge browser...
        return _ret = self, _possibleConstructorReturn(_this, _ret);
      }

      _createClass(Expression, [{
        key: 'clone',
        value: function clone() {
          var copy;
          copy = _get(Expression.prototype.__proto__ || Object.getPrototypeOf(Expression.prototype), 'clone', this).apply(this, arguments);
          if (this.convert != null) {
            copy.convert = this.convert;
          }
          return copy;
        }
      }, {
        key: 'compile',
        value: function compile() {
          var _this2 = this;

          var ref;
          this.debug(function () {
            return '[compile] enter... (' + _this2.resolved + ')';
          });
          this.emit('compiling', arguments);
          if (!this.resolved) {
            if ((ref = this.resolve) != null) {
              ref.apply(this, arguments);
            }
          }
          if (this.tag != null && !this.argument) {
            throw this.error('cannot contain argument \'' + this.tag + '\' for expression \'' + this.kind + '\'');
          }
          if (this.argument && this.tag == null) {
            throw this.error('must contain argument \'' + this.argument + '\' for expression \'' + this.kind + '\'');
          }
          if (this.exprs.length) {
            this.debug(function () {
              return 'has sub-expressions: ' + _this2.exprs.map(function (x) {
                return x.kind;
              });
            });
          }
          this.exprs.forEach(function (x) {
            return x.compile();
          });
          this.resolved = true;
          this.emit('compiled');
          this.debug(function () {
            return "[compile] done";
          });
          return this;
        }
      }, {
        key: 'bind',
        value: function bind(data) {
          var _this3 = this;

          if (data != null) {
            this.debug(function () {
              return '[bind] registering ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + ' binding';
            });
            this.binding = data;
            this.emit('bind', data); // allows unbinding...
          } else {
            this.debug(function () {
              return '[bind] removing prior ' + _typeof(_this3.binding) + ' binding';
            });
            this.binding = void 0;
          }
          return this;
        }

        // internally used to apply the expression to the passed in data

      }, {
        key: 'apply',
        value: function apply(data, ctx, opts) {
          var e, expr, i, len, ref, ref1;
          if (!this.resolved) {
            this.compile();
          }
          this.emit('transforming', data);
          if (this.transform instanceof Function) {
            data = this.transform.call(this, data, ctx, opts);
          } else {
            ref = this.exprs;
            for (i = 0, len = ref.length; i < len; i++) {
              expr = ref[i];
              if (data != null) {
                data = expr.eval(data, ctx, opts);
              }
            }
          }
          try {
            if ((ref1 = this.predicate) != null) {
              ref1.call(this, data, opts);
            }
          } catch (error) {
            e = error;
            this.debug(function () {
              return data;
            });
            throw this.error('predicate validation error: ' + e, data);
          }
          this.emit('transformed', data);
          return data;
        }

        // evalute the provided data

      }, {
        key: 'eval',
        value: function _eval(data, ctx, opts) {
          if (!this.resolved) {
            this.compile();
          }
          if (this.construct instanceof Function) {
            if (data == null) {
              data = {};
            }
            return this.construct.call(this, data, ctx, opts);
          } else {
            return this.apply(data, ctx, opts);
          }
        }
      }, {
        key: 'update',
        value: function update(elem) {
          var res;
          res = _get(Expression.prototype.__proto__ || Object.getPrototypeOf(Expression.prototype), 'update', this).apply(this, arguments);
          res.binding = elem.binding;
          return res;
        }
      }, {
        key: 'error',
        value: function error() {
          var res;
          res = _get(Expression.prototype.__proto__ || Object.getPrototypeOf(Expression.prototype), 'error', this).apply(this, arguments);
          res.message = '[' + this.uri + '] ' + res.message;
          res.name = 'ExpressionError';
          return res;
        }
      }]);

      return Expression;
    }(Element);

    ;

    Expression.prototype.logger = require('debug')('yang:expression');

    // Source delegation

    delegate(Expression.prototype, 'source').getter('scope').getter('resolve').getter('transform').getter('construct').getter('predicate').getter('compose');

    delegate(Expression.prototype, 'state').access('binding').access('resolved');

    Expression.property('argument', {
      get: function get() {
        var ref;
        return (ref = this.state.argument) != null ? ref : this.source.argument;
      },
      set: function set(value) {
        return this.state.argument = value;
      }
    });

    Expression.property('exprs', {
      get: function get() {
        return this.children.filter(function (x) {
          return x instanceof Expression;
        });
      }
    });

    Expression.property('nodes', {
      get: function get() {
        return this.exprs.filter(function (x) {
          return x.node === true;
        });
      }
    });

    Expression.property('attrs', {
      get: function get() {
        return this.exprs.filter(function (x) {
          return x.node === false;
        });
      }
    });

    Expression.property('node', {
      get: function get() {
        return this.construct instanceof Function;
      }
    });

    Expression.property('data', {
      get: function get() {
        return Boolean(this.source.data);
      }
    });

    Expression.property('*', {
      get: function get() {
        return this.nodes;
      }
    });

    return Expression;
  }.call(this);

  module.exports = Expression;
}).call(undefined);

},{"./element":3,"debug":25,"delegates":27}],5:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Expression, Extension;

  Expression = require('./expression');

  Extension = function () {
    var Extension = function (_Expression) {
      _inherits(Extension, _Expression);

      function Extension(name) {
        var spec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Extension);

        if (spec.scope == null) {
          spec.scope = {};
        }
        return _possibleConstructorReturn(this, (Extension.__proto__ || Object.getPrototypeOf(Extension)).call(this, 'extension', name, spec));
      }

      return Extension;
    }(Expression);

    ;

    Extension.prototype.logger = require('debug')('yang:extension');

    Extension.scope = {
      argument: '0..1',
      description: '0..1',
      reference: '0..1',
      status: '0..1'
    };

    return Extension;
  }.call(this);

  module.exports = Extension;
}).call(undefined);

},{"./expression":4,"debug":25}],6:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.5.1
(function () {
  var Container, Context, Extension, List, Method, Model, Notification, Property, Store, Typedef, XPath, Yang;

  Yang = require('./yang');

  XPath = require('./xpath');

  Extension = require('./extension');

  Typedef = require('./typedef');

  Context = require('./context');

  Store = require('./store');

  Model = require('./model');

  Container = require('./container');

  List = require('./list');

  Method = require('./method');

  Notification = require('./notification');

  Property = require('./property');

  module.exports = { Yang: Yang, Extension: Extension, Typedef: Typedef, XPath: XPath, Context: Context, Store: Store, Model: Model, Container: Container, List: List, Method: Method, Notification: Notification, Property: Property };
}).call(undefined);

},{"./container":1,"./context":2,"./extension":5,"./list":10,"./method":11,"./model":12,"./notification":13,"./property":14,"./store":15,"./typedef":16,"./xpath":17,"./yang":18}],7:[function(require,module,exports){
'use strict';

// Generated by CoffeeScript 2.5.1
(function () {
  var P, identifier, optSep;

  P = require('xparse').Parser;

  optSep = P.space.skipMany();

  identifier = P.variable.bind(function (v) {
    return P.alphanum.orElse(P.oneOf(':.-')).concat().bind(function (rest) {
      return P.unit(v + rest);
    });
  });

  module.exports = {
    'node-identifier': P.create(function () {
      return identifier;
    }),
    'if-feature-expr': P.create(function () {
      var _expr, _factor, _term;
      _expr = function expr() {
        return P.union.step(_term, _expr);
      };
      _term = function term() {
        return P.combine.step(_factor, _term);
      };
      _factor = function factor() {
        return P.choice(P.negate.bind(function (op) {
          return _factor().bind(function (f) {
            return P.wrap(op, f);
          });
        }), P.char('(').bind(function () {
          return optSep.bind(function () {
            return _expr().bind(function (e) {
              return optSep.bind(function () {
                return P.char(')').bind(function () {
                  return P.unit(e);
                });
              });
            });
          });
        }), identifier.bind(function (kw) {
          return P.wrap(null, kw);
        }));
      };
      return _expr().within(optSep);
    })
  };
}).call(undefined);

},{"xparse":37}],8:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Generated by CoffeeScript 2.5.1
(function () {
  var ARGUMENT_NAMES,
      Arguments,
      Container,
      Extension,
      List,
      Method,
      Model,
      Notification,
      Property,
      STRIP_COMMENTS,
      XPath,
      Yang,
      assert,
      hasProp = {}.hasOwnProperty,
      indexOf = [].indexOf;

  var _require = require('..');

  Yang = _require.Yang;
  Extension = _require.Extension;
  XPath = _require.XPath;
  Model = _require.Model;
  Container = _require.Container;
  List = _require.List;
  Method = _require.Method;
  Notification = _require.Notification;
  Property = _require.Property;


  Arguments = require('./arguments');

  assert = require('assert');

  STRIP_COMMENTS = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/mg;

  ARGUMENT_NAMES = /([^\s,]+)/g;

  module.exports = [new Extension('action', {
    argument: 'name',
    scope: {
      description: '0..1',
      grouping: '0..n',
      'if-feature': '0..n',
      input: '0..1',
      output: '0..1',
      reference: '0..1',
      status: '0..1',
      typedef: '0..n'
    },
    predicate: function predicate() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      return assert(data instanceof Function, "data must contain a valid instanceof Function");
    },
    resolve: function resolve() {
      if (!this.input) {
        this.extends(new Yang('input'));
      }
      if (!this.output) {
        return this.extends(new Yang('output'));
      }
    },
    transform: function transform(data, ctx, opts) {
      var expr, i, len, ref1;
      if (data == null) {
        return;
      }
      if (!(data instanceof Function)) {
        this.debug(function () {
          return data;
        });
        // TODO: allow data to be a 'string' compiled into a Function?
        throw this.error('expected a function but got a \'' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '\'');
      }
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        data = expr.eval(data, ctx, opts);
      }
      return data;
    },
    construct: function construct() {
      var _ref;

      return (_ref = new Method({
        name: this.tag,
        schema: this
      })).attach.apply(_ref, arguments);
    },
    compose: function compose(data) {
      var _ref2;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var expr, i, kind, len, match, matches, possibilities;
      if (!(data instanceof Function)) {
        return;
      }
      if (Object.keys(data).length !== 0) {
        return;
      }
      if (!(data.prototype == null || Object.keys(data.prototype).length === 0)) {
        return;
      }
      possibilities = function () {
        var ref1, results;
        ref1 = this.scope;
        results = [];
        for (kind in ref1) {
          if (!hasProp.call(ref1, kind)) continue;
          results.push(this.lookup('extension', kind));
        }
        return results;
      }.call(this);
      matches = [];
      for (i = 0, len = possibilities.length; i < len; i++) {
        expr = possibilities[i];
        if (!(expr != null)) {
          continue;
        }
        match = typeof expr.compose === "function" ? expr.compose(data) : void 0;
        if (match != null) {
          matches.push(match);
        }
      }
      return (_ref2 = new Yang(this.tag, opts.tag, this)).extends.apply(_ref2, _toConsumableArray(matches));
    }
  }), new Extension('anydata', {
    argument: 'name',
    data: true,
    scope: {
      config: '0..1',
      description: '0..1',
      'if-feature': '0..n',
      mandatory: '0..1',
      must: '0..n',
      reference: '0..1',
      status: '0..1',
      when: '0..1'
    },
    construct: function construct() {
      var _ref3;

      return (_ref3 = new Property(this)).attach.apply(_ref3, arguments);
    }
  }), new Extension('anyxml', {
    argument: 'name',
    data: true,
    scope: {
      config: '0..1',
      description: '0..1',
      'if-feature': '0..n',
      mandatory: '0..1',
      must: '0..n',
      reference: '0..1',
      status: '0..1',
      when: '0..1'
    },
    construct: function construct() {
      var _ref4;

      return (_ref4 = new Property(this)).attach.apply(_ref4, arguments);
    }
  }), new Extension('argument', {
    argument: 'arg-type',
    scope: {
      'yin-element': '0..1'
    }
  }), new Extension('augment', {
    argument: 'target-node',
    scope: {
      action: '0..n',
      anydata: '0..n',
      anyxml: '0..n',
      case: '0..n',
      choice: '0..n',
      container: '0..n',
      description: '0..1',
      'if-feature': '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      notification: '0..n',
      reference: '0..1',
      status: '0..1',
      uses: '0..n',
      when: '0..1'
    },
    resolve: function resolve() {
      var _this = this;

      var target;
      target = function () {
        switch (this.parent.kind) {
          case 'module':
            if (!/^\//.test(this.tag)) {
              throw this.error('\'' + this.tag + '\' must be absolute-schema-path to augment within module statement');
            }
            return this.locate(this.tag);
          default:
            if (!/^[_0-9a-zA-Z]/.test(this.tag)) {
              throw this.error('\'' + this.tag + '\' must be relative-schema-path to augment within uses statement');
            }
            return this.parent.state.grouping.locate(this.tag);
        }
      }.call(this);
      if (target == null) {
        console.warn(this.error('unable to locate \'' + this.tag + '\''));
        return;
      }
      if (this.when == null) {
        return this.once('compiled', function () {
          _this.debug(function () {
            return 'augmenting \'' + target.kind + ':' + target.tag + '\'';
          });
          return target.extends(_this.nodes.map(function (x) {
            return x.clone({
              origin: _this,
              relative: false
            });
          }));
        });
      } else {
        return target.on('transformed', function (data) {
          var expr, i, len, ref1, results;
          if (data != null) {
            ref1 = _this.exprs;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              expr = ref1[i];
              results.push(data = expr.apply(data));
            }
            return results;
          }
        });
      }
    },
    transform: function transform(data) {
      return data;
    }
  }), new Extension('base', {
    argument: 'name',
    resolve: function resolve() {
      var ref;
      ref = this.state.identity = this.lookup('identity', this.tag);
      if (ref == null) {
        throw this.error('unable to resolve \'' + this.tag + '\' identity');
      }
    }
  }), new Extension('belongs-to', {
    argument: 'module-name',
    scope: {
      prefix: '1'
    },
    resolve: function resolve() {
      this.module = this.lookup('module', this.tag);
      if (this.module == null) {
        throw this.error('unable to resolve \'' + this.tag + '\' module');
      }
    }
  }), new Extension('bit', {
    argument: 'name',
    scope: {
      description: '0..1',
      'if-feature': '0..n', // YANG 1.1
      reference: '0..1',
      status: '0..1',
      position: '0..1'
    },
    resolve: function resolve() {
      var base, cval;
      if ((base = this.parent).bitPosition == null) {
        base.bitPosition = 0;
      }
      if (this.position == null) {
        return this.extends(this.constructor.parse('position ' + this.parent.bitPosition++ + ';'));
      } else {
        cval = Number(this.position.tag) + 1;
        if (!(this.parent.bitPosition > cval)) {
          return this.parent.bitPosition = cval;
        }
      }
    }
  }), new Extension('case', {
    argument: 'name',
    scope: {
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      container: '0..n',
      description: '0..1',
      'if-feature': '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      reference: '0..1',
      status: '0..1',
      uses: '0..n',
      when: '0..1'
    },
    resolve: function resolve() {
      var _this2 = this;

      return this.once('compiled', function () {
        if (!(_this2.nodes.length > 0)) {
          throw _this2.error("cannot have an empty case statement");
        }
      });
    },
    transform: function transform(data, ctx, opts) {
      var expr, i, keys, len, ref1;
      if (!(data instanceof Object)) {
        return data;
      }
      keys = Object.keys(data);
      if (!this.nodes.some(function (x) {
        var ref1;
        return ref1 = x.tag, indexOf.call(keys, ref1) >= 0;
      })) {
        return data;
      }
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        data = expr.eval(data, ctx, opts);
      }
      return data;
    },
    predicate: function predicate(data) {
      assert(data instanceof Object, "data must contain Object data");
      return assert(this.nodes.some(function (x) {
        return x.tag in data;
      }), "data must contain a matching element");
    }
  }), new Extension('choice', {
    argument: 'condition',
    data: true,
    scope: {
      anyxml: '0..n',
      case: '0..n',
      config: '0..1',
      container: '0..n',
      default: '0..1',
      description: '0..1',
      'if-feature': '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      mandatory: '0..1',
      reference: '0..1',
      status: '0..1',
      when: '0..1'
    },
    resolve: function resolve() {
      var ref1;
      if (this.case != null && this.nodes.length) {
        throw this.error("cannot contain short-hand non-case data node statement when using case statements");
      }
      if (this.nodes.length) {
        this.extends(this.nodes.map(function (node) {
          return new Yang('case', node.tag).extends(node);
        }));
        this.removes(this.nodes);
      }
      if (((ref1 = this.mandatory) != null ? ref1.tag : void 0) === 'true' && this.default != null) {
        throw this.error("cannot define 'default' when 'mandatory' is true");
      }
      if (this.default != null && this.match('case', this.default.tag) == null) {
        throw this.error('cannot specify default \'' + this.default.tag + '\' without a corresponding case');
      }
    },
    // TODO: need to ensure each nodes in case are unique
    transform: function transform(data, ctx, opts) {
      var _this3 = this;

      var attr, block, defcase, expr, i, j, l, len, len1, len2, len3, m, match, ref1, ref2, ref3, ref4;
      if (this.case == null) {
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          data = expr.eval(data, ctx, opts);
        }
        return data;
      }
      ref2 = this.case;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        block = ref2[j];
        this.debug(function () {
          return 'checking if case ' + block.tag + '...';
        });
        try {
          data = block.eval(data, ctx, opts);
          match = block.tag;
          break;
        } catch (error) {}
      }
      switch (false) {
        case !(match == null && this.default != null):
          this.debug(function () {
            return 'choice fallback to default: ' + _this3.default.tag;
          });
          match = this.default.tag;
          defcase = this.match('case', this.default.tag);
          ref3 = defcase.exprs;
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            expr = ref3[l];
            data = expr.eval(data, ctx, opts);
          }
          break;
        case !(match == null && this.mandatory != null):
          throw this.error("no matching choice found (mandatory)");
      }
      ref4 = this.attrs;
      for (m = 0, len3 = ref4.length; m < len3; m++) {
        attr = ref4[m];
        if (attr.kind !== 'case') {
          data = attr.eval(data, ctx, opts);
        }
      }
      // TODO: need to address multiple choices in the data object
      Object.defineProperty(data, '@choice', {
        value: match
      });
      return data;
    },
    construct: function construct() {
      return this.apply.apply(this, arguments); // considered to be a 'node'
    }
  }), new Extension('config', {
    argument: 'value',
    resolve: function resolve() {
      var _this4 = this;

      this.tag = this.tag === true || this.tag === 'true';
      return this.parent.once('compiled', function () {
        return _this4.parent.nodes.map(function (node) {
          try {
            return node.update(_this4);
          } catch (error) {}
        });
      });
    }
  }), new Extension('contact', {
    argument: 'text',
    yin: true
  }), new Extension('container', {
    argument: 'name',
    data: true,
    scope: {
      action: '0..n',
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      config: '0..1',
      container: '0..n',
      description: '0..1',
      grouping: '0..n',
      'if-feature': '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      must: '0..n',
      notification: '0..n',
      presence: '0..1',
      reference: '0..1',
      status: '0..1',
      typedef: '0..n',
      uses: '0..n',
      when: '0..1'
    },
    predicate: function predicate() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return assert((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object', "data must contain instance of Object");
    },
    construct: function construct() {
      var _ref5;

      return (_ref5 = new Container(this)).attach.apply(_ref5, arguments);
    },
    compose: function compose(data) {
      var _ref6;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var expr, i, k, kind, len, match, matches, parents, possibilities, ref1, v;
      if (!(data === Object(data) && !Array.isArray(data))) {
        return;
      }
      // return unless typeof data is 'object' and Object.keys(data).length > 0
      // return if data instanceof Array
      possibilities = function () {
        var ref1, results;
        ref1 = this.scope;
        results = [];
        for (kind in ref1) {
          if (!hasProp.call(ref1, kind)) continue;
          results.push(this.lookup('extension', kind));
        }
        return results;
      }.call(this);
      matches = [];
      parents = (ref1 = opts.parents) != null ? ref1 : [];
      parents.push(data);
      for (k in data) {
        if (!hasProp.call(data, k)) continue;
        try {
          v = data[k];
        } catch (error) {
          continue;
        }
        if (indexOf.call(parents, v) >= 0) {
          this.debug(function () {
            return 'found circular entry for \'' + k + '\'';
          });
          matches.push(new Yang('anydata', k, this));
          continue;
        }
        for (i = 0, len = possibilities.length; i < len; i++) {
          expr = possibilities[i];
          if (!((expr != null ? expr.compose : void 0) != null)) {
            continue;
          }
          this.debug(function () {
            return 'checking \'' + k + '\' to see if ' + expr.tag;
          });
          match = expr.compose(v, {
            tag: k,
            parents: parents
          });
          if (match != null) {
            break;
          }
        }
        if (match == null) {
          return;
        }
        matches.push(match);
      }
      parents.pop();
      return (_ref6 = new Yang(this.tag, opts.tag, this)).extends.apply(_ref6, _toConsumableArray(matches));
    }
  }), new Extension('default', {
    argument: 'value',
    transform: function transform(data) {
      return data != null ? data : this.tag;
    }
  }), new Extension('description', {
    argument: 'text',
    yin: true
  }),
  // TODO
  new Extension('deviate', {
    argument: 'value',
    scope: {
      config: '0..1',
      default: '0..1',
      mandatory: '0..1',
      'max-elements': '0..1',
      'min-elements': '0..1',
      must: '0..n',
      type: '0..1',
      unique: '0..1',
      units: '0..1'
    }
  }),
  // TODO
  new Extension('deviation', {
    argument: 'target-node',
    scope: {
      description: '0..1',
      deviate: '1..n',
      reference: '0..1'
    }
  }), new Extension('enum', {
    argument: 'name',
    scope: {
      description: '0..1',
      'if-feature': '0..n', // YANG 1.1
      reference: '0..1',
      status: '0..1',
      value: '0..1'
    },
    resolve: function resolve() {
      var base, cval;
      if ((base = this.parent).enumValue == null) {
        base.enumValue = 0;
      }
      if (this.value == null) {
        return this.extends(this.constructor.parse('value ' + this.parent.enumValue++ + ';'));
      } else {
        cval = Number(this.value.tag) + 1;
        if (!(this.parent.enumValue > cval)) {
          return this.parent.enumValue = cval;
        }
      }
    }
  }), new Extension('error-app-tag', {
    argument: 'value'
  }), new Extension('error-message', {
    argument: 'value',
    yin: true
  }), new Extension('extension', {
    argument: 'extension-name',
    scope: {
      argument: '0..1',
      description: '0..1',
      reference: '0..1',
      status: '0..1'
    },
    resolve: function resolve() {
      var _this5 = this;

      if (this.kind !== 'extension') {
        if (this.argument === 'extension-name') {
          // NOTE: we can't do a simple 'delete this.argument' since we
          // used delegates to bind getter/setter to the instance
          // prototype
          this.argument = false;
        }
      }
      this.debug(function () {
        return 'setting state of new extension unbound';
      });
      this.state.unbound = true;
      return this.once('bind', function () {
        var ext, key, name, opts, prefix, ref1, ref2, ref3, value;
        prefix = _this5.lookup('prefix');
        name = prefix + ':' + _this5.tag;
        _this5.debug(function () {
          return 'registering new bound extension \'' + name + '\'';
        });
        opts = _this5.binding;
        if (opts.argument == null) {
          opts.argument = (ref1 = _this5.argument) != null ? ref1.valueOf() : void 0;
        }
        _this5.source = new Extension('' + name, opts);
        if (opts.global === true) {
          _this5.constructor.scope[name] = '0..n';
        }
        ref3 = (ref2 = opts.target) != null ? ref2 : {};
        for (key in ref3) {
          value = ref3[key];
          ext = _this5.lookup('extension', key);
          if (ext != null) {
            ext.scope[name] = value;
          }
        }
        _this5.constructor.use(_this5.source);
        _this5.state.unbound = false;
        return _this5.emit('bound');
      });
    }
  }), new Extension('feature', {
    argument: 'name',
    scope: {
      description: '0..1',
      'if-feature': '0..n',
      reference: '0..1',
      status: '0..1'
    }
  }),
  // transform: (data, ctx) ->
  //   feature = @binding
  //   feature = expr.eval feature, ctx for expr in @exprs when feature?
  //   (new Property @tag, this).attach(ctx.instance) if ctx?.instance? and feature?
  //   return data
  new Extension('fraction-digits', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = Number(this.tag);
    }
  }), new Extension('grouping', {
    argument: 'name',
    scope: {
      action: '0..n',
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      container: '0..n',
      description: '0..1',
      grouping: '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      notification: '0..n',
      reference: '0..1',
      status: '0..1',
      typedef: '0..n',
      uses: '0..n'
    },
    transform: function transform(data, ctx) {
      var _this6 = this;

      var expr, i, len, prop, ref1;
      if (ctx == null) {
        this.debug(function () {
          return 'applying grouping schema ' + _this6.tag + ' directly';
        });
        prop = new Container({
          name: this.tag,
          schema: this
        }).set(data, {
          preserve: true
        });
        data = prop.data; // applied directly
      }
      if ((ctx != null ? ctx.schema : void 0) === this) {
        ref1 = this.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          expr = ref1[i];
          if (data != null) {
            data = expr.eval(data, ctx);
          }
        }
      }
      return data;
    }
  }), new Extension('identity', {
    argument: 'name',
    scope: {
      base: '0..1',
      description: '0..1',
      reference: '0..1',
      status: '0..1'
    },
    // TODO: resolve 'base' statements
    resolve: function resolve() {
      if (this.base != null) {
        return this.lookup('identity', this.base.tag);
      }
    }
  }), new Extension('if-feature', {
    argument: 'if-feature-expr',
    resolve: function resolve() {
      var _this7 = this;

      var expr, name1, ref1, target, test;
      expr = typeof Arguments[name1 = this.argument] === "function" ? Arguments[name1](this.tag) : void 0;
      test = function test(kw) {
        var ref1;
        return ((ref1 = _this7.lookup('feature', kw)) != null ? ref1.binding : void 0) != null;
      };
      target = this.parent;
      return target != null ? (ref1 = target.parent) != null ? ref1.on('transforming', function () {
        if (!(typeof expr === "function" ? expr(test) : void 0)) {
          _this7.debug(function () {
            return 'removed ' + target.kind + ':' + target.tag + ' due to missing feature(s): ' + _this7.tag;
          });
          return target.parent.remove(target);
        }
      }) : void 0 : void 0;
    }
  }), new Extension('import', {
    argument: 'module',
    scope: {
      prefix: '1',
      'revision-date': '0..1',
      description: '0..1', // YANG 1.1
      reference: '0..1' // YANG 1.1
    },
    resolve: function resolve() {
      var module, ref1, rev;
      module = this.lookup('module', this.tag);
      if (module == null) {
        throw this.error('unable to resolve \'' + this.tag + '\' module');
      }
      // defined as non-enumerable
      Object.defineProperty(this, 'module', {
        configurable: true,
        value: module
      });
      rev = (ref1 = this['revision-date']) != null ? ref1.tag : void 0;
      if (rev != null && this.module.match('revision', rev) == null) {
        throw this.error('requested ' + rev + ' not available in ' + this.tag);
      }
    },
    transform: function transform(data, ctx) {
      var _this8 = this;

      // below is a very special transform
      if (this.module.nodes.length && Object.isExtensible(data) && (ctx != null ? ctx.store : void 0) != null) {
        if (!ctx.store.has(this.module.tag)) {
          this.debug(function () {
            return 'IMPORT: absorbing data for \'' + _this8.tag + '\'';
          });
          this.module.eval(data, ctx);
        }
      }
      // XXX - we probably don't need to do this...
      // @module.nodes.forEach (x) -> delete data[x.datakey]
      return data;
    }
  }), new Extension('include', {
    argument: 'module',
    scope: {
      'revision-date': '0..1',
      description: '0..1', // YANG 1.1
      reference: '0..1' // YANG 1.1
    },
    resolve: function resolve() {
      var i, len, mod, ref1, sub, x;
      sub = this.lookup('submodule', this.tag);
      if (sub == null) {
        throw this.error('unable to resolve \'' + this.tag + '\' submodule');
      }
      mod = function () {
        switch (this.root.kind) {
          case 'module':
            return this.root;
          case 'submodule':
            return this.root['belongs-to'].module;
        }
      }.call(this);
      if (mod.tag !== sub['belongs-to'].tag) {
        throw this.error('requested submodule \'' + this.tag + '\' not belongs-to \'' + mod.tag + '\'');
      }
      // defined as non-enumerable
      Object.defineProperty(sub['belongs-to'], 'module', {
        configurable: true,
        value: mod
      });
      ref1 = sub.compile().children;
      for (i = 0, len = ref1.length; i < len; i++) {
        x = ref1[i];
        if (sub.scope[x.kind] === '0..n' && x.kind !== 'revision') {
          //@debug => "updating parent with #{x.kind}(#{x.tag})"
          this.parent.update(x);
        }
      }
      return sub.parent = this;
    }
  }), new Extension('input', {
    data: true,
    scope: {
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      container: '0..n',
      grouping: '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      must: '0..n', // RFC 7950
      typedef: '0..n',
      uses: '0..n'
    },
    //resolve: -> @tag = null if !@tag
    transform: function transform(data, ctx) {
      var expr, i, len, ref1;
      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
        return;
      }
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        if (data != null) {
          data = expr.eval(data, ctx);
        }
      }
      return data;
    },
    construct: function construct() {
      var _ref7;

      return (_ref7 = new Container(this)).attach.apply(_ref7, arguments);
    },
    compose: function compose(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var ref1, res, str;
      if (!(data instanceof Function)) {
        return;
      }
      str = data.toString().replace(STRIP_COMMENTS, '');
      res = (ref1 = str.slice(str.indexOf('(') + 1, str.indexOf(')')).match(ARGUMENT_NAMES)) != null ? ref1 : [];
      if (data.length !== res.length) {
        this.debug(function () {
          return 'argument length mismatch: expected ' + data.length + ' but got ' + res.length;
        });
      }
      return new Yang(this.tag, null, this).extends(res.map(function (x) {
        return Yang('anydata ' + x + ';');
      }));
    }
  }), new Extension('key', {
    argument: 'value',
    resolve: function resolve() {
      var _this9 = this;

      return this.parent.once('compiled', function () {
        _this9.tag = _this9.tag.split(' ');
        if (!_this9.tag.every(function (k) {
          return _this9.parent.match('leaf', k) != null;
        })) {
          throw _this9.error("unable to reference key items as leaf elements", _this9.parent);
        }
      });
    },
    predicate: function predicate(data) {
      if (!(data instanceof Object)) {
        return;
      }
      if (data instanceof Array) {
        return;
      }
      return assert(this.tag.every(function (k) {
        return data.hasOwnProperty(k);
      }), "data must contain values for all key leafs");
    },
    transform: function transform(data, ctx) {
      var _this10 = this;

      var exists;
      if (!(data instanceof Object)) {
        return data;
      }
      switch (false) {
        case !Array.isArray(data):
          exists = {};
          data.forEach(function (item) {
            var key;
            if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
              return;
            }
            key = item['@key'];
            if (exists[key]) {
              _this10.debug(function () {
                return 'found key conflict for ' + key + ' inside ' + _this10.parent.tag;
              });
              throw _this10.error('key conflict for ' + key, item);
            }
            return exists[key] = true;
          });
          break;
        case !!data.hasOwnProperty('@key'):
          Object.defineProperty(data, '@key', {
            get: function () {
              return this.tag.map(function (k) {
                return data[k];
              }).join(',');
            }.bind(this)
          });
      }
      //ctx.state.key = data['@key'] if ctx?.state?
      return data;
    }
  }), new Extension('leaf', {
    argument: 'name',
    data: true,
    scope: {
      config: '0..1',
      default: '0..1',
      description: '0..1',
      'if-feature': '0..n',
      mandatory: '0..1',
      must: '0..n',
      reference: '0..1',
      status: '0..1',
      type: '0..1',
      units: '0..1',
      when: '0..1'
    },
    resolve: function resolve() {
      var ref1;
      if (((ref1 = this.mandatory) != null ? ref1.tag : void 0) === 'true' && this.default != null) {
        throw this.error("cannot define 'default' when 'mandatory' is true");
      }
    },
    predicate: function predicate(data) {
      if (data instanceof Error) {
        return;
      }
      if (data instanceof Array) {
        return assert(data.length === 1 && data[0] === null, "data cannot be an Array");
      }
    },
    transform: function transform(data, ctx, opts) {
      var expr, i, len, ref1;
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        if (expr.kind !== 'type') {
          data = expr.eval(data, ctx, opts);
        }
      }
      if (this.type != null) {
        data = this.type.apply(data, ctx, opts);
      }
      return data;
    },
    construct: function construct() {
      var _ref8;

      return (_ref8 = new Property(this)).attach.apply(_ref8, arguments);
    },
    compose: function compose(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var ref1, type;
      if (data instanceof Array) {
        return;
      }
      if (data instanceof Object && Object.keys(data).length > 0) {
        return;
      }
      type = (ref1 = this.lookup('extension', 'type')) != null ? typeof ref1.compose === "function" ? ref1.compose(data) : void 0 : void 0;
      if (type == null) {
        return;
      }
      this.debug(function () {
        return 'detected \'' + opts.tag + '\' as ' + (type != null ? type.tag : void 0);
      });
      return new Yang(this.tag, opts.tag, this).extends(type);
    }
  }), new Extension('leaf-list', {
    argument: 'name',
    data: true,
    scope: {
      config: '0..1',
      default: '0..n', // RFC 7950
      description: '0..1',
      'if-feature': '0..n',
      'max-elements': '0..1',
      'min-elements': '0..1',
      must: '0..n',
      'ordered-by': '0..1',
      reference: '0..1',
      status: '0..1',
      type: '0..1',
      units: '0..1',
      when: '0..1'
    },
    predicate: function predicate(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (data != null && opts.strict) {
        return assert(data instanceof Array, "data must contain an Array");
      }
    },
    transform: function transform(data, ctx, opts) {
      var expr, i, len, ref1, ref2;
      if (data == null) {
        data = (ref1 = this.default) != null ? ref1.keys : void 0;
      }
      if (typeof data === 'string') {
        data = data.split(/\s*,\s*/);
      }
      if (data != null && !Array.isArray(data)) {
        data = [data];
      }
      if (data != null) {
        data = Array.from(new Set(data)).filter(function (x) {
          return x !== void 0 && x !== null;
        });
      }
      ref2 = this.exprs;
      for (i = 0, len = ref2.length; i < len; i++) {
        expr = ref2[i];
        if (expr.kind !== 'type') {
          data = expr.eval(data, ctx, opts);
        }
      }
      if (this.type != null) {
        data = this.type.apply(data, ctx, opts);
      }
      return data;
    },
    construct: function construct() {
      var _ref9;

      return (_ref9 = new Property(this)).attach.apply(_ref9, arguments);
    },
    compose: function compose(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var i, item, len, res, type_, types;
      if (!(data instanceof Array)) {
        return;
      }
      type_ = this.lookup('extension', 'type');
      types = [];
      for (i = 0, len = data.length; i < len; i++) {
        item = data[i];
        res = typeof type_.compose === "function" ? type_.compose(item) : void 0;
        if (res == null) {
          return;
        }
        types.push(res);
      }
      // return unless data.every (x) -> typeof x isnt 'object'
      // types = data.map (x) -> type_.compose? x
      // TODO: form a type union if more than one types
      return new Yang(this.tag, opts.tag, this).extends(types[0]);
    }
  }), new Extension('length', {
    argument: 'value',
    scope: {
      description: '0..1',
      'error-app-tag': '0..1',
      'error-message': '0..1',
      reference: '0..1'
    }
  }), new Extension('list', {
    argument: 'name',
    data: true,
    scope: {
      action: '0..n', // v1.1
      anydata: '0..n', // v1.1
      anyxml: '0..n',
      choice: '0..n',
      config: '0..1',
      container: '0..n',
      description: '0..1',
      grouping: '0..n',
      'if-feature': '0..n',
      key: '0..1',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      'max-elements': '0..1',
      'min-elements': '0..1',
      must: '0..n',
      notification: '0..n',
      'ordered-by': '0..1',
      reference: '0..1',
      status: '0..1',
      typedef: '0..n',
      unique: '0..1',
      uses: '0..n',
      when: '0..1'
    },
    predicate: function predicate() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return assert(data instanceof Object, "data must be an Object");
    },
    transform: function transform(data, ctx, opts) {
      var _this11 = this;

      var attr, i, j, len, len1, node, ref1, ref2;
      if (data == null) {
        return;
      }
      if (Array.isArray(data)) {
        data = data.map(function (item) {
          return new List.Item(_this11).attach(item, ctx, opts);
        });
      } else {
        ref1 = this.nodes;
        for (i = 0, len = ref1.length; i < len; i++) {
          node = ref1[i];
          if (data != null) {
            data = node.eval(data, ctx, opts);
          }
        }
      }
      ref2 = this.attrs;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        attr = ref2[j];
        if (data != null) {
          data = attr.eval(data, ctx, opts);
        }
      }
      return data;
    },
    construct: function construct() {
      var _ref10;

      return (_ref10 = new List(this)).attach.apply(_ref10, arguments);
    },
    compose: function compose(data) {
      var _ref11;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var expr, i, k, kind, len, match, matches, parents, possibilities, ref1, v;
      if (!(data instanceof Array && data.length > 0)) {
        return;
      }
      if (!data.every(function (x) {
        return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object';
      })) {
        return;
      }
      // TODO: inspect more than first element
      data = data[0];
      possibilities = function () {
        var ref1, results;
        ref1 = this.scope;
        results = [];
        for (kind in ref1) {
          if (!hasProp.call(ref1, kind)) continue;
          results.push(this.lookup('extension', kind));
        }
        return results;
      }.call(this);
      matches = [];
      parents = (ref1 = opts.parents) != null ? ref1 : [];
      parents.push(data);
      for (k in data) {
        if (!hasProp.call(data, k)) continue;
        v = data[k];
        if (indexOf.call(parents, v) >= 0) {
          this.debug(function () {
            return 'found circular entry for \'' + k + '\'';
          });
          matches.push(new Yang('anydata', k, this));
          continue;
        }
        for (i = 0, len = possibilities.length; i < len; i++) {
          expr = possibilities[i];
          if (!(expr != null)) {
            continue;
          }
          match = typeof expr.compose === "function" ? expr.compose(v, {
            tag: k,
            parents: parents
          }) : void 0;
          if (match != null) {
            break;
          }
        }
        if (match == null) {
          return;
        }
        matches.push(match);
      }
      parents.pop();
      return (_ref11 = new Yang(this.tag, opts.tag, this)).extends.apply(_ref11, _toConsumableArray(matches));
    }
  }), new Extension('mandatory', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = this.tag === true || this.tag === 'true';
    },
    predicate: function predicate(data) {
      return assert(this.tag !== true || data != null || this.parent.binding != null, "data must be defined");
    }
  }), new Extension('max-elements', {
    argument: 'value',
    resolve: function resolve() {
      if (this.tag !== 'unbounded') {
        return this.tag = Number(this.tag);
      }
    },
    predicate: function predicate(data) {
      return assert(this.tag === 'unbounded' || !(data instanceof Array) || data.length <= this.tag, 'data must contain less than maximum entries (' + this.tag + ')');
    }
  }), new Extension('min-elements', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = Number(this.tag);
    },
    predicate: function predicate(data) {
      return assert(!(data instanceof Array) || data.length >= this.tag, 'data must contain more than minimum entries (' + this.tag + ')');
    }
  }),
  // TODO
  new Extension('modifier', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = this.tag === 'invert-match';
    }
  }), new Extension('module', {
    argument: 'name',
    scope: {
      anydata: '0..n',
      anyxml: '0..n',
      augment: '0..n',
      choice: '0..n',
      contact: '0..1',
      container: '0..n',
      description: '0..1',
      deviation: '0..n',
      extension: '0..n',
      feature: '0..n',
      grouping: '0..n',
      identity: '0..n',
      import: '0..n',
      include: '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      namespace: '0..1',
      notification: '0..n',
      organization: '0..1',
      prefix: '0..1',
      reference: '0..1',
      revision: '0..n',
      rpc: '0..n',
      typedef: '0..n',
      uses: '0..n',
      'yang-version': '0..1'
    },
    resolve: function resolve() {
      var _this12 = this;

      var ref1, ref2;
      if (((ref1 = this['yang-version']) != null ? ref1.tag : void 0) === '1.1') {
        if (!(this.namespace != null && this.prefix != null)) {
          throw this.error("must define 'namespace' and 'prefix' for YANG 1.1 compliance");
        }
      }
      if (((ref2 = this.extension) != null ? ref2.length : void 0) > 0) {
        return this.debug(function () {
          return 'found ' + _this12.extension.length + ' new extension(s)';
        });
      }
    },
    transform: function transform(data, ctx, opts) {
      var expr, i, len, ref1;
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        if (data != null && expr.kind !== 'extension') {
          data = expr.eval(data, ctx, opts);
        }
      }
      return data;
    },
    construct: function construct() {
      var _ref12;

      return (_ref12 = new Model({
        name: this.tag,
        schema: this
      })).attach.apply(_ref12, arguments);
    }
  }),
  // TODO
  new Extension('must', {
    argument: 'condition',
    scope: {
      description: '0..1',
      'error-app-tag': '0..1',
      'error-message': '0..1',
      reference: '0..1'
    }
  }), new Extension('namespace', {
    argument: 'value'
  }), new Extension('notification', {
    argument: 'event',
    data: true,
    scope: {
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      container: '0..n',
      description: '0..1',
      grouping: '0..n',
      'if-feature': '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      must: '0..n', // RFC 7950
      reference: '0..1',
      status: '0..1',
      typedef: '0..n',
      uses: '0..n'
    },
    construct: function construct() {
      var _ref13;

      return (_ref13 = new Notification(this)).attach.apply(_ref13, arguments);
    }
  }), new Extension('ordered-by', {
    argument: 'value'
  }), new Extension('organization', {
    argument: 'text',
    yin: true
  }), new Extension('output', {
    data: true,
    scope: {
      anydata: '0..n',
      anyxml: '0..n',
      choice: '0..n',
      container: '0..n',
      grouping: '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      must: '0..n', // RFC 7950
      typedef: '0..n',
      uses: '0..n'
    },
    transform: function transform(data, ctx) {
      var expr, i, len, ref1;
      if (data instanceof Promise) {
        return data;
      }
      ref1 = this.exprs;
      for (i = 0, len = ref1.length; i < len; i++) {
        expr = ref1[i];
        if (data != null) {
          data = expr.eval(data, ctx);
        }
      }
      return data;
    },
    construct: function construct() {
      var _ref14;

      return (_ref14 = new Container(this)).attach.apply(_ref14, arguments);
    }
  }), new Extension('path', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = this.normalizePath(this.tag);
    }
  }), new Extension('pattern', {
    argument: 'value',
    scope: {
      description: '0..1',
      'error-app-tag': '0..1',
      'error-message': '0..1',
      modifier: '0..1',
      reference: '0..1'
    },
    resolve: function resolve() {
      return this.tag = new RegExp('^(?:' + this.tag + ')$');
    }
  }), new Extension('position', {
    argument: 'value'
  }), new Extension('prefix', {
    argument: 'value',
    resolve: function resolve() {} // should validate prefix naming convention
  }), new Extension('presence', {
    argument: 'value'
  }), new Extension('range', {
    argument: 'value',
    scope: {
      description: '0..1',
      'error-app-tag': '0..1',
      'error-message': '0..1',
      reference: '0..1'
    }
  }), new Extension('reference', {
    argument: 'value'
  }), new Extension('refine', {
    argument: 'target-node',
    scope: {
      default: '0..1',
      description: '0..1',
      reference: '0..1',
      config: '0..1',
      'if-feature': '0..n', // YANG 1.1
      mandatory: '0..1',
      presence: '0..1',
      must: '0..n',
      'min-elements': '0..1',
      'max-elements': '0..1',
      units: '0..1'
    },
    resolve: function resolve() {
      var _this13 = this;

      var target;
      target = this.parent.state.grouping.locate(this.tag);
      if (target == null) {
        console.warn(this.error('unable to locate \'' + this.tag + '\''));
        return;
      }
      this.debug(function () {
        return 'APPLY ' + _this13 + ' to ' + target;
      });
      // TODO: revisit this logic, may need to 'merge' the new expr into existing expr
      return this.exprs.forEach(function (expr) {
        var ref1;
        switch (false) {
          case !target.hasOwnProperty(expr.kind):
            if ((ref1 = expr.kind) === 'must' || ref1 === 'if-feature') {
              return target.extends(expr);
            } else {
              return target.merge(expr, {
                replace: true
              });
            }
            break;
          default:
            return target.extends(expr);
        }
      });
    }
  }), new Extension('require-instance', {
    argument: 'value',
    resolve: function resolve() {
      return this.tag = this.tag === true || this.tag === 'true';
    }
  }), new Extension('revision', {
    argument: 'date',
    scope: {
      description: '0..1',
      reference: '0..1',
      status: '0..1' // deviation from RFC 6020
    }
  }), new Extension('revision-date', {
    argument: 'date'
  }), new Extension('rpc', {
    argument: 'name',
    scope: {
      description: '0..1',
      grouping: '0..n',
      'if-feature': '0..n',
      input: '0..1',
      output: '0..1',
      reference: '0..1',
      status: '0..1',
      typedef: '0..n'
    },
    predicate: function predicate() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      return assert(data instanceof Function, "data must be a Function");
    },
    resolve: function resolve() {
      if (!this.input) {
        this.extends(new Yang('input'));
      }
      if (!this.output) {
        return this.extends(new Yang('output'));
      }
    },
    transform: function transform(data, ctx, opts) {
      var attr, i, len, ref1;
      if (data == null) {
        return;
      }
      if (!(data instanceof Function)) {
        this.debug(function () {
          return data;
        });
        // TODO: allow data to be a 'string' compiled into a Function?
        throw this.error('expected a function but got a \'' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '\'');
      }
      ref1 = this.attrs;
      for (i = 0, len = ref1.length; i < len; i++) {
        attr = ref1[i];
        data = attr.eval(data, ctx, opts);
      }
      return data;
    },
    construct: function construct() {
      var _ref15;

      return (_ref15 = new Method(this)).attach.apply(_ref15, arguments);
    }
  }), new Extension('status', {
    argument: 'value',
    resolve: function resolve() {
      var ref1;
      return this.tag = (ref1 = this.tag) != null ? ref1 : 'current';
    }
  }), new Extension('submodule', {
    argument: 'name',
    scope: {
      anyxml: '0..n',
      augment: '0..n',
      'belongs-to': '0..1',
      choice: '0..n',
      contact: '0..1',
      container: '0..n',
      description: '0..1',
      deviation: '0..n',
      extension: '0..n',
      feature: '0..n',
      grouping: '0..n',
      identity: '0..n',
      import: '0..n',
      include: '0..n',
      leaf: '0..n',
      'leaf-list': '0..n',
      list: '0..n',
      notification: '0..n',
      organization: '0..1',
      reference: '0..1',
      revision: '0..n',
      rpc: '0..n',
      typedef: '0..n',
      uses: '0..n',
      'yang-version': '0..1'
    }
  }), new Extension('type', {
    argument: 'name',
    scope: {
      base: '0..1',
      bit: '0..n',
      enum: '0..n',
      'fraction-digits': '0..1',
      length: '0..1',
      path: '0..1',
      pattern: '0..n',
      range: '0..1',
      'require-instance': '0..1',
      type: '0..n' // for 'union' case only
    },
    resolve: function resolve() {
      var _this14 = this;

      var convert, ref1, typedef;
      if (this.type != null && this.tag !== 'union') {
        throw this.error("cannot have additional type definitions unless 'union'");
      }
      typedef = this.lookup('typedef', this.tag);
      if (typedef == null) {
        this.debug(function () {
          return _this14.parent;
        });
        throw this.error('unable to resolve typedef for ' + this.tag);
      }
      if (typedef.type != null) {
        this.once('compiled', function () {
          var expr, i, len, ref1, results;
          ref1 = typedef.type.exprs;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            expr = ref1[i];
            try {
              results.push(_this14.merge(expr));
            } catch (error) {}
          }
          return results;
        });
      }
      convert = typedef.convert;
      if (convert == null) {
        convert = typedef.compile().convert;
      }
      if (convert == null) {
        throw this.error('no convert found for ' + typedef.tag);
      }
      this.state.basetype = (ref1 = typedef.basetype) != null ? ref1 : typedef.state.basetype;
      this.convert = convert.bind(this);
      if (this.parent != null && this.parent.kind !== 'type') {
        try {
          return this.parent.extends(typedef.default, typedef.units);
        } catch (error) {}
      }
    },
    transform: function transform(data, ctx, opts) {
      var _this15 = this;

      var res;
      if (!(data !== void 0 && (data instanceof Array || !(data instanceof Object)))) {
        return data;
      }
      if (data instanceof Array) {
        res = data.map(function (x) {
          return _this15.convert(x, ctx, opts);
        });
        if (!ctx.attached && res.some(function (x) {
          return x instanceof Error;
        })) {
          ctx.defer(data);
        }
      } else {
        res = this.convert(data, ctx, opts);
        if (!ctx.attached && res instanceof Error) {
          ctx.defer(data);
        }
      }
      return res;
    },
    compose: function compose(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var e, i, len, ref1, typedef, typedefs;
      if (data instanceof Function) {
        return;
      }
      //return if data instanceof Object and Object.keys(data).length > 0
      typedefs = this.lookup('typedef');
      ref1 = typedefs.concat({
        tag: 'unknown'
      });
      for (i = 0, len = ref1.length; i < len; i++) {
        typedef = ref1[i];
        this.debug(function () {
          return 'checking if ' + typedef.tag;
        });
        try {
          if (typedef.convert(data) !== void 0) {
            break;
          }
        } catch (error) {
          e = error;
          this.debug(function () {
            return e.message;
          });
        }
      }
      if (typedef.tag === 'unknown') {
        return;
      }
      return new Yang(this.tag, typedef.tag);
    }
  }),
  // TODO: address deviation from the conventional pattern
  new Extension('typedef', {
    argument: 'name',
    scope: {
      default: '0..1',
      description: '0..1',
      units: '0..1',
      type: '0..1',
      reference: '0..1',
      status: '0..1'
    },
    resolve: function resolve() {
      var builtin;
      if (this.type != null) {
        this.convert = this.type.compile().convert;
        this.state.basetype = this.type.state.basetype;
        return;
      }
      builtin = this.lookup('typedef', this.tag);
      if (builtin == null) {
        throw this.error('unable to resolve \'' + this.tag + '\' built-in type');
      }
      this.state.basetype = builtin.basetype;
      return this.convert = builtin.convert;
    }
  }), new Extension('unique', {
    argument: 'tag',
    resolve: function resolve() {
      var _this16 = this;

      return this.parent.once('compiled', function () {
        _this16.tag = _this16.tag.split(' ');
        if (!_this16.tag.every(function (k) {
          var ref1;
          return ((ref1 = _this16.parent.locate(k)) != null ? ref1.kind : void 0) === 'leaf';
        })) {
          throw _this16.error("referenced unique items do not have leaf elements");
        }
      });
    },
    predicate: function predicate(data) {
      var _this17 = this;

      var isUnique, seen;
      if (!(data instanceof Array)) {
        return;
      }
      seen = {};
      isUnique = data.every(function (item) {
        var key;
        if (!_this17.tag.every(function (k) {
          return item[k] != null;
        })) {
          return true;
        }
        key = _this17.tag.reduce(function (a, b) {
          return a += item[b];
        }, '');
        if (seen[key]) {
          return false;
        }
        seen[key] = true;
        return true;
      });
      return assert(isUnique, 'data must contain unique entries of ' + this.tag);
    }
  }), new Extension('units', {
    argument: 'value'
  }), new Extension('uses', {
    argument: 'grouping-name',
    scope: {
      augment: '0..n',
      description: '0..1',
      'if-feature': '0..n',
      refine: '0..n',
      reference: '0..1',
      status: '0..1',
      when: '0..1'
    },
    resolve: function resolve() {
      var _this18 = this;

      var grouping, ref;
      grouping = this.lookup('grouping', this.tag);
      if (grouping == null) {
        throw this.error('unable to resolve ' + this.tag + ' grouping definition');
      }
      // setup change linkage to upstream definition
      //grouping.on 'changed', => @emit 'changed'

      // NOTE: declared as non-enumerable
      //Object.defineProperty this, 'grouping', value: 
      if (this.when == null) {
        ref = this.state.grouping = grouping.clone().compile();
        this.debug(function () {
          return 'extending with ' + ref.nodes.length + ' elements';
        });
        return this.parent.extends(ref.nodes);
      } else {
        return this.parent.on('transformed', function (data) {
          var expr, i, len, ref1, results;
          if (data != null) {
            ref1 = _this18.exprs;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              expr = ref1[i];
              results.push(data = expr.apply(data));
            }
            return results;
          }
        });
      }
    },
    transform: function transform(data) {
      return data;
    }
  }), new Extension('value', {
    argument: 'value' // required
  }),

  // TODO
  new Extension('when', {
    argument: 'condition',
    scope: {
      description: '0..1',
      reference: '0..1'
    }
  }), new Extension('yang-version', {
    argument: 'value'
  }), new Extension('yin-element', {
    argument: 'value'
  })];
}).call(undefined);

},{"..":6,"./arguments":7,"assert":19}],9:[function(require,module,exports){
(function (Buffer){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Integer, Typedef, generateRangeTest;

  var _require = require('..');

  Typedef = _require.Typedef;


  generateRangeTest = function generateRangeTest(expr) {
    var max, min;

    var _expr$split = expr.split(/\s*\.\.\s*/);

    var _expr$split2 = _slicedToArray(_expr$split, 2);

    min = _expr$split2[0];
    max = _expr$split2[1];

    min = Number(min);
    max = function () {
      switch (false) {
        case max !== 'max':
          return null;
        default:
          return Number(max);
      }
    }();
    return function (v) {
      return (min == null || v >= min) && (max == null || v <= max);
    };
  };

  Integer = function (_Typedef) {
    _inherits(Integer, _Typedef);

    function Integer(name, range) {
      _classCallCheck(this, Integer);

      var source;
      source = {
        construct: function construct(value, ctx) {
          var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          var ranges, ref, tests;
          if (Number.isNaN(Number(value)) || Number(value) % 1 !== 0) {
            throw ctx.error('[' + this.tag + '] unable to convert \'' + value + '\'');
          }
          // treat '' string as undefined
          if (typeof value === 'string' && value === '') {
            return;
          }
          if (opts.strict && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== number) {
            throw ctx.error('[' + this.tag + '] must be a number but got ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
          }
          value = Number(value);
          ranges = (ref = this.range) != null ? ref.tag.split('|') : void 0;
          if (ranges != null && ranges.length) {
            tests = ranges.map(generateRangeTest);
          }
          if (!(tests == null || tests.some(function (test) {
            return typeof test === "function" ? test(value) : void 0;
          }))) {
            throw ctx.error('[' + this.tag + '] custom range violation for \'' + value + '\' on ' + ranges);
          }
          if (!generateRangeTest(range)(value)) {
            throw ctx.error('[' + this.tag + '] range violation for \'' + value + '\' on ' + range);
          }
          return value;
        }
      };
      return _possibleConstructorReturn(this, (Integer.__proto__ || Object.getPrototypeOf(Integer)).call(this, name, source));
    }

    return Integer;
  }(Typedef);

  module.exports = [new Typedef('bits', {
    construct: function construct(value, ctx) {
      var ref;
      if (!(((ref = this.bit) != null ? ref.length : void 0) > 0)) {
        throw ctx.error('[' + this.tag + '] must have one or more \'bit\' definitions');
      }
      if (!(value != null && typeof value === 'string')) {
        return;
      }
      // TODO: handle value a number in the future
      value = value.split(' ');
      if (!value.every(function (v) {
        return this.bit.some(function (b) {
          return b.tag === v;
        });
      })) {
        throw ctx.error('[' + this.tag + '] invalid bit name(s) for \'' + value + '\' on ' + this.bit.map(function (x) {
          return x.tag;
        }));
      }
      return value;
    }
  }), new Typedef('boolean', {
    construct: function construct(value, ctx) {
      switch (false) {
        case typeof value !== 'string':
          if (value !== 'true' && value !== 'false') {
            throw ctx.error('[' + this.tag + '] ' + value + ' must be \'true\' or \'false\'');
          }
          return value === 'true';
        case typeof value !== 'boolean':
          return value;
        default:
          throw ctx.error('[' + this.tag + '] unable to convert \'' + value + '\'');
      }
    }
  }), new Typedef('empty', {
    construct: function construct(value, ctx) {
      this.debug(function () {
        return "convert";
      });
      this.debug(function () {
        return value;
      });
      if (value !== null) {
        throw ctx.error('[' + this.tag + '] cannot contain value other than null');
      }
      return null;
    }
  }), new Typedef('binary', {
    construct: function construct(value, ctx) {
      if (!(value instanceof Buffer)) {
        throw ctx.error('[' + this.tag + '] unable to convert \'' + value + '\'');
      }
      return value;
    }
  }), new Integer('int8', '-128..127'), new Integer('int16', '-32768..32767'), new Integer('int32', '-2147483648..2147483647'), new Integer('int64', '-9223372036854775808..9223372036854775807'), new Integer('uint8', '0..255'), new Integer('uint16', '0..65535'), new Integer('uint32', '0..4294967295'), new Integer('uint64', '0..18446744073709551615'), new Typedef('decimal64', {
    construct: function construct(value, ctx) {
      var a, b, fixed, ranges, ref, ref1, tests;
      if (Number.isNaN(Number(value))) {
        throw ctx.error('[' + this.tag + '] unable to convert \'' + value + '\'');
      }
      // treat '' string as undefined
      if (typeof value === 'string' && value === '') {
        return;
      }
      fixed = ((ref = this['fraction-digits']) != null ? ref.tag : void 0) || 1;

      var _value$toString$split = value.toString().split('.');

      var _value$toString$split2 = _slicedToArray(_value$toString$split, 2);

      a = _value$toString$split2[0];
      b = _value$toString$split2[1];

      if ((b != null ? b.length : void 0) > fixed) {
        throw ctx.error('[' + this.tag + '] fraction-digits violation for \'' + value + '\' with more than ' + fixed + ' decimal precision');
      }
      value = Number(Number(value).toFixed(fixed));
      ranges = (ref1 = this.range) != null ? ref1.tag.split('|') : void 0;
      if (ranges != null && ranges.length) {
        tests = ranges.map(generateRangeTest);
      }
      if (!(tests == null || tests.some(function (test) {
        return typeof test === "function" ? test(value) : void 0;
      }))) {
        throw ctx.error('[' + this.tag + '] custom range violation for \'' + value + '\' on ' + ranges);
      }
      return value;
    }
  }), new Typedef('string', {
    construct: function construct(value, ctx) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var lengths, patterns, ref, ref1, tests, type;
      patterns = (ref = this.pattern) != null ? ref.map(function (x) {
        return x.tag;
      }) : void 0;
      lengths = (ref1 = this.length) != null ? ref1.tag.split('|') : void 0;
      tests = lengths != null ? lengths.map(function (e) {
        var max, min;

        var _e$split = e.split(/\s*\.\.\s*/);

        var _e$split2 = _slicedToArray(_e$split, 2);

        min = _e$split2[0];
        max = _e$split2[1];

        min = Number(min);
        max = function () {
          switch (false) {
            case !(max == null):
              return min;
            case max !== 'max':
              return null;
            default:
              return Number(max);
          }
        }();
        return function (v) {
          return (min == null || v.length >= min) && (max == null || v.length <= max);
        };
      }) : void 0;
      if (value === null) {
        return;
      }
      type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      if (opts.strict && type !== 'string') {
        throw ctx.error('[' + this.tag + '] must be a string but got ' + type);
      }
      value = String(value);
      if (type === 'object' && /^\[object/.test(value)) {
        throw ctx.error('[' + this.tag + '] unable to convert \'' + value + '\' into string');
      }
      if (!(tests == null || tests.some(function (test) {
        return typeof test === "function" ? test(value) : void 0;
      }))) {
        throw ctx.error('[' + this.tag + '] length violation for \'' + value + '\' on ' + lengths);
      }
      if (!(patterns == null || patterns.every(function (regex) {
        return regex.test(value);
      }))) {
        throw ctx.error('[' + this.tag + '] pattern violation for \'' + value + '\'');
      }
      return value;
    }
  }), new Typedef('union', {
    construct: function construct(value, ctx) {
      var j, len, ref, type;
      if (this.type == null) {
        throw ctx.error('[' + this.tag + '] must contain one or more type definitions');
      }
      ref = this.type;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        try {
          return type.convert(value);
        } catch (error) {
          continue;
        }
      }
      throw ctx.error('[' + this.tag + '] unable to find matching type for \'' + value + '\' within: ' + this.type);
    }
  }), new Typedef('enumeration', {
    construct: function construct(value, ctx) {
      var i, j, len, ref, ref1;
      if (!(((ref = this.enum) != null ? ref.length : void 0) > 0)) {
        throw ctx.error('[' + this.tag + '] must have one or more \'enum\' definitions');
      }
      ref1 = this.enum;
      for (j = 0, len = ref1.length; j < len; j++) {
        i = ref1[j];
        if (value === i.tag) {
          return i.tag;
        }
        if (value === i.value.tag) {
          return i.tag;
        }
        if ('' + value === i.value.tag) {
          return i.tag;
        }
      }
      throw ctx.error('[' + this.tag + '] type violation for \'' + value + '\' on ' + this.enum.map(function (x) {
        return x.tag;
      }));
    }
  }),
  // TODO
  new Typedef('identityref', {
    construct: function construct(value, ctx) {
      var _this2 = this;

      var dep, imports, j, k, len, len1, m, match, modules, ref;
      if (!(this.base != null && typeof this.base.tag === 'string')) {
        throw ctx.error('[' + this.tag + '] must reference \'base\' identity');
      }
      return value; // BYPASS FOR NOW
      match = this.lookup('identity', value);
      if (match == null) {
        imports = (ref = this.lookup('import')) != null ? ref : [];
        for (j = 0, len = imports.length; j < len; j++) {
          dep = imports[j];
          match = dep.module.lookup('identity', value);
          if (match != null) {
            break;
          }
        }
        if (match == null) {
          modules = this.lookup('module');
          this.debug(function () {
            return 'fallback searching all modules ' + modules.map(function (x) {
              return x.tag;
            });
          });
          for (k = 0, len1 = modules.length; k < len1; k++) {
            m = modules[k];
            match = m.lookup('identity', value);
            if (match != null) {
              break;
            }
          }
        }
      }
      if ((match != null ? match.base : void 0) != null) {
        match = match.base.state.identity;
      }
      this.debug(function () {
        return 'base: ' + _this2.base + ' match: ' + match + ' value: ' + value;
      });
      // TODO - need to figure out how to return namespace value...
      if (!(match != null && this.base.state.identity === match)) {
        throw ctx.error('[' + this.tag + '] identityref is invalid for \'' + value + '\'');
      }
      return value;
    }
  }), new Typedef('instance-identifier', {
    construct: function construct(value, ctx) {
      var e, err, prop, ref;
      this.debug(function () {
        return 'processing instance-identifier with ' + value;
      });
      try {
        prop = ctx.in(value);
        if (prop == null) {
          throw ctx.error("missing schema element, identifier is invalid");
        }
        if (((ref = this['require-instance']) != null ? ref.tag : void 0) && !prop.active) {
          throw ctx.error("missing instance data");
        }
      } catch (error) {
        e = error;
        err = new Error('[' + this.tag + '] ' + ctx.name + ' is invalid for \'' + value + '\' (not found in ' + value + ')');
        err['error-tag'] = 'data-missing';
        err['error-app-tag'] = 'instance-required';
        err['err-path'] = value;
        err.toString = function () {
          return value;
        };
        if (ctx.attached) {
          throw ctx.error(err);
        }
        return err;
      }
      return value;
    }
  }), new Typedef('leafref', {
    construct: function construct(value, ctx) {
      var _this3 = this;

      var err, ref, res, valid;
      if (this.path == null) {
        throw new Error('[' + this.tag + '] must contain \'path\' statement');
      }
      if (((ref = this['require-instance']) != null ? ref.tag : void 0) === false) {
        return value;
      }
      this.debug(function () {
        return 'processing leafref with ' + _this3.path.tag;
      });
      res = ctx.get(this.path.tag);
      this.debug(function () {
        return 'got back ' + res;
      });
      valid = function () {
        switch (false) {
          case !(res instanceof Array):
            return res.some(function (x) {
              return '' + x === '' + value;
            });
          default:
            return '' + res === '' + value;
        }
      }();
      if (valid !== true) {
        this.debug(function () {
          return 'invalid leafref \'' + value + '\' detected for ' + _this3.path.tag;
        });
        this.debug(function () {
          return ctx.state;
        });
        err = new Error('[' + this.tag + '] ' + ctx.name + ' is invalid for \'' + value + '\' (not found in ' + this.path.tag + ')');
        err['error-tag'] = 'data-missing';
        err['error-app-tag'] = 'instance-required';
        err['err-path'] = this.path.tag;
        err.toString = function () {
          return value;
        };
        if (ctx.attached) {
          throw ctx.error(err);
        }
        return err;
      }
      return value;
    }
  })];
}).call(undefined);

}).call(this,require("buffer").Buffer)
},{"..":6,"buffer":23}],10:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Container, List, ListItem, Property, XPath, delegate;

  delegate = require('delegates');

  Container = require('./container');

  Property = require('./property');

  XPath = require('./xpath');

  ListItem = function () {
    var ListItem = function (_Container) {
      _inherits(ListItem, _Container);

      function ListItem() {
        _classCallCheck(this, ListItem);

        return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
      }

      _createClass(ListItem, [{
        key: 'merge',
        value: function merge() {
          var prevkey, ref;
          prevkey = this.key;
          _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'merge', this).apply(this, arguments);
          if (prevkey !== this.key) {
            if ((ref = this.parent) != null) {
              if (typeof ref.remove === "function") {
                ref.remove({
                  key: prevkey
                });
              }
            }
          }
          return this;
        }
      }, {
        key: 'update',
        value: function update(value, opts) {
          // @debug => "[update] prior key is: #{@key}"
          if (this.keys.length && value != null && !(value instanceof Property)) {
            if ('@key' in value) {
              this.state.key = value['@key'];
            }
          }
          // @debug => "[update] current key is: #{@key}"
          return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'update', this).apply(this, arguments);
        }
      }, {
        key: 'attach',
        value: function attach(obj, parent, opts) {
          if (!(obj instanceof Object)) {
            throw this.error("list item must be an object", 'attach');
          }
          if (opts == null) {
            opts = {
              replace: false,
              force: false
            };
          }
          this.parent = parent;
          if (!this.keys.length) {
            this.state.key = this;
          }
          // list item directly applies the passed in object
          this.set(obj, opts);
          this.state.attached = true;
          return obj;
        }
      }, {
        key: 'revert',
        value: async function revert(opts) {
          var ref;
          if (!this.changed) {
            return;
          }
          await _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'revert', this).call(this, opts);
          return (ref = this.parent) != null ? ref.update(this) : void 0;
        }
      }, {
        key: 'find',
        value: function find(pattern) {
          var _parent;

          switch (false) {
            // here we skip a level of hierarchy
            case !(/^\.\./.test(pattern) && this.parent != null):
              return (_parent = this.parent).find.apply(_parent, arguments);
            default:
              return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'find', this).apply(this, arguments);
          }
        }
      }, {
        key: 'inspect',
        value: function inspect() {
          var res;
          res = _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'inspect', this).apply(this, arguments);
          res.key = this.key;
          res.keys = this.keys;
          return res;
        }
      }]);

      return ListItem;
    }(Container);

    ;

    ListItem.prototype.logger = require('debug')('yang:list:item');

    delegate(ListItem.prototype, 'state').getter('key');

    ListItem.property('uri', {
      get: function get() {
        var ref;
        switch (false) {
          case this.parent == null:
            return this.parent.uri + '[\'' + this.key + '\']';
          default:
            return (ref = this.schema.datapath) != null ? ref : this.schema.uri;
        }
      }
    });

    // @property 'uri',
    //   get: -> (@schema.datapath ? @schema.uri) + "['#{@key}']" 
    ListItem.property('keys', {
      get: function get() {
        if (this.schema.key) {
          return this.schema.key.tag;
        } else {
          return [];
        }
      }
    });

    ListItem.property('pos', {
      get: function get() {
        var _this2 = this;

        if (this.parent != null) {
          return this.parent.props.findIndex(function (x) {
            return x === _this2;
          }) + 1;
        }
      }
    });

    ListItem.property('path', {
      get: function get() {
        var entity;
        entity = function () {
          switch (false) {
            case !this.keys.length:
              return '.[\'' + this.key + '\']';
            default:
              return '.[' + this.pos + ']';
          }
        }.call(this);
        if (this.parent == null) {
          return XPath.parse(entity, this.schema);
        }
        // XXX - do not cache into @state.path since keys may change...
        return this.parent.path.clone().append(entity);
      }
    });

    return ListItem;
  }.call(this);

  List = function () {
    var List = function (_Container2) {
      _inherits(List, _Container2);

      function List() {
        _classCallCheck(this, List);

        return _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).apply(this, arguments));
      }

      _createClass(List, [{
        key: '_key',

        // private methods
        value: function _key(s) {
          return 'key(' + s + ')';
        }
      }, {
        key: 'add',
        value: function add(child) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var key;
          if (!child.active) {
            return;
          }
          if (this.schema.key != null) {
            key = this._key(child.key);
            if (this.has(key) && this._get(key) !== child) {
              this.pending.delete(child.key);
              throw this.error('cannot update due to key conflict: ' + child.key, 'add');
            }
            return this.children.set(key, child);
          } else {
            return this.children.set(child);
          }
        }
      }, {
        key: 'remove',
        value: function remove(child) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var key;
          if (this.schema.key != null) {
            key = this._key(child.key);
            if (this._get(key) === child) {
              return this.children.delete(key);
            }
          } else {
            return this.children.delete(child);
          }
        }
      }, {
        key: 'equals',
        value: function equals(a, b) {
          if (!(Array.isArray(a) && Array.isArray(b) && a.length === b.length)) {
            return false;
          }
          // figure out how to deal with empty array later...
          // return true if a.length is 0
          return false;
        }

        // a.every (x) => b.some (y) => x is y

        // public methods

      }, {
        key: 'has',
        value: function has(key) {
          return typeof key === 'string' && this.schema.key != null && _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'has', this).call(this, key);
        }
      }, {
        key: 'set',
        value: function set(data) {
          var _this4 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var err, prev;
          if (data != null && !Array.isArray(data)) {
            throw this.error("list must be an array", 'set');
          }
          if (data != null) {
            data = [].concat(data).filter(Boolean);
          }
          prev = this.props;
          this.children.clear();
          try {
            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'set', this).call(this, data, opts);
          } catch (error) {
            err = error;
            this.children.clear();
            prev.forEach(function (prop) {
              return _this4.add(prop);
            });
            throw err;
          }
          return this;
        }
      }, {
        key: 'merge',
        value: function merge(data) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var attr, creates, e, item, j, key, l, len, len1, newlist, ref, results, subopts, vopts;
          if (opts.origin == null) {
            opts.origin = this;
          }
          if (data != null) {
            data = [].concat(data).filter(Boolean);
          }
          if (data === null) {
            return this.delete(opts);
          }
          if (!this.children.size || opts.replace) {
            return this.set(data, opts);
          }
          if (data == null) {
            return this; // do nothing if data is undefined
          }
          creates = [];
          subopts = Object.assign({}, opts, {
            inner: true
          });
          for (j = 0, len = data.length; j < len; j++) {
            item = data[j];
            if (this.schema.key != null && !opts.createOnly) {
              try {
                //pre = process.memoryUsage()
                item = this.schema.key.apply(item);
                key = this._key(item['@key']);
              } catch (error) {}
              if (this.has(key)) {
                if (!opts.appendOnly) {
                  this.debug(function () {
                    return '[merge] merge into list item for ' + key;
                  });
                  this.debug(function () {
                    return item;
                  });
                  this._get(key).merge(item, subopts);
                  this.debug(function () {
                    return '[merge] merge done for list item ' + key;
                  });
                }
                //post = process.memoryUsage()
                //console.log("item growth: %d KB", (post.heapUsed - pre.heapUsed) / 1024);    
                continue;
              }
            }
            creates.push(item);
          }
          try {
            if (creates.length) {
              this.schema.apply(creates, this, subopts);
            }
          } catch (error) {
            e = error;
            throw this.error(e, 'create');
          }
          this.update(this, opts); // pass itself if merging

          // here, we validate the other min/max type schema attributes
          // use synchronous opts so that we do not do any await
          vopts = Object.assign({}, opts, {
            sync: true
          });
          newlist = this.props.map(function (p) {
            return p.value;
          });
          try {
            ref = this.schema.attrs;
            results = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              attr = ref[l];
              results.push(attr.apply(newlist, this, vopts));
            }
            return results;
          } catch (error) {
            e = error;
            this.revert(vopts);
            throw this.error(e, 'create');
          }
        }
      }, {
        key: 'update',
        value: function update(value, opts) {
          if (value instanceof ListItem && !value.active) {
            this.remove(value);
          }
          return _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'update', this).call(this, value, opts);
        }
      }, {
        key: 'revert',
        value: async function revert() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var err, ref;
          if (!this.changed) {
            return;
          }
          if (!this.replaced) {
            // revisit if we need to do this
            return _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'revert', this).call(this, opts);
          }

          // TODO: find a more optimal way to revert entire list?
          this.debug('[revert] complete list... ' + this.replaced);
          this.set(this.state.prior, {
            force: true // this will trigger 'update' events!
          });
          if (!opts.sync) {
            this.debug("[revert] execute binding...");
          }
          try {
            if (!opts.sync) {
              await ((ref = this.binding) != null ? typeof ref.commit === "function" ? ref.commit(this.context.with(opts)) : void 0 : void 0);
            }
          } catch (error) {
            err = error;
            this.debug('[revert] failed due to ' + err.message);
            throw this.error(err, 'revert');
          }
          return this.clean(opts);
        }
      }, {
        key: 'toJSON',
        value: function toJSON(key) {
          var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var value;
          value = function () {
            switch (false) {
              case !this.children.size:
                return this.props.map(function (x) {
                  return x.toJSON(false, state);
                });
              default:
                return this.value;
            }
          }.call(this);
          if (key === true) {
            value = _defineProperty({}, '' + this.name, value);
          }
          return value;
        }
      }]);

      return List;
    }(Container);

    ;

    List.prototype.logger = require('debug')('yang:list');

    List.Item = ListItem;

    List.property('value', {
      get: function get() {
        switch (false) {
          case this.state.value == null:
            return this.props.map(function (item) {
              return item.data;
            }).filter(Boolean);
          default:
            return [];
        }
      }
    });

    List.property('props', {
      get: function get() {
        switch (false) {
          case this.schema.key == null:
            return Array.from(this.children.values());
          default:
            return Array.from(this.children.keys());
        }
      }
    });

    List.property('changed', {
      get: function get() {
        return this.pending.size > 0 || this.state.changed && !this.active;
      }
    });

    List.property('active', {
      get: function get() {
        return this.enumerable && this.children.size > 0;
      }
    });

    List.property('change', {
      get: function get() {
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !(this.changed && this.pending.size):
            return Array.from(this.changes).filter(function (i) {
              return i.active;
            }).map(function (i) {
              var j, k, len, obj, ref;
              obj = i.change;
              if (obj != null) {
                ref = i.keys;
                for (j = 0, len = ref.length; j < len; j++) {
                  k = ref[j];
                  obj[k] = i.get(k);
                }
              }
              return obj;
            });
        }
      }
    });

    return List;
  }.call(this);

  module.exports = List;
}).call(undefined);

},{"./container":1,"./property":14,"./xpath":17,"debug":25,"delegates":27}],11:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Method - controller of functions

  // ## Class Method
  var Method, Property;

  Property = require('./property');

  Method = function () {
    var Method = function (_Property) {
      _inherits(Method, _Property);

      function Method() {
        _classCallCheck(this, Method);

        return _possibleConstructorReturn(this, (Method.__proto__ || Object.getPrototypeOf(Method)).apply(this, arguments));
      }

      _createClass(Method, [{
        key: 'do',

        // ### do ()

        // A convenience wrap to a Property instance that holds a function to
        // perform a Promise-based execution.

        // Always returns a Promise.
        value: async function _do() {
          var _this2 = this;

          var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var ctx, e, output, ref, ref1;
          if (!(this.binding instanceof Function || this.data instanceof Function)) {
            return Promise.reject(this.error("cannot perform action on a property without function"));
          }
          this.debug('[do] executing method: ' + this.name);
          this.debug(input);
          ctx = (ref = (ref1 = this.parent) != null ? ref1.context : void 0) != null ? ref : this.context;
          ctx = ctx.with(opts, {
            path: this.path
          });
          try {
            // calling context is the parent node of the method
            input = this.schema.input.apply(input, this, {
              force: true
            });

            // first apply schema bound function (if availble), otherwise
            // execute assigned function (if available and not 'missing')
            if (this.binding != null) {
              if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {
                this.debug('[do] calling bound function with: ' + Object.keys(input));
              }
              this.debug(this.binding.toString());
              output = typeof this.binding === "function" ? this.binding(ctx, input) : void 0;
            } else {
              this.debug('[do] calling assigned function: ' + this.data.name);
              this.debug(function () {
                return _this2.value;
              });
              this.debug(function () {
                return _this2.data;
              });
              output = this.data.call(this.parent.data, input, ctx);
            }
            output = await output;

            var _schema$output$eval = this.schema.output.eval({ output: output }, this, {
              force: true
            });

            output = _schema$output$eval.output;

            return output;
          } catch (error) {
            e = error;
            this.debug(e);
            return Promise.reject(e);
          }
        }
      }, {
        key: 'update',
        value: function update(value, opts) {
          if (!(value instanceof Property)) {
            return _get(Method.prototype.__proto__ || Object.getPrototypeOf(Method.prototype), 'update', this).call(this, value, opts);
          }
        }

        // ### toJSON

        // This call always returns undefined for the Method node.

      }, {
        key: 'toJSON',
        value: function toJSON(key) {
          var value;
          value = void 0;
          if (key === true) {
            value = _defineProperty({}, '' + this.name, value);
          }
          return value;
        }
      }]);

      return Method;
    }(Property);

    ;

    Method.prototype.logger = require('debug')('yang:method');

    Method.property('data', {
      set: function set(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function get() {
        switch (false) {
          case this.binding == null:
            return this.do.bind(this);
          default:
            return this.value;
        }
      }
    });

    return Method;
  }.call(this);

  module.exports = Method;
}).call(undefined);

},{"./property":14,"debug":25}],12:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Model - instance of schema-driven data

  // The `Model` class aggregates [Property](./property.litcoffee)
  // attachments to provide the *adaptive* and *event-driven* data
  // interactions.

  // It is typically not instantiated directly, but is generated as a
  // result of [Yang::eval](../yang.litcoffee#eval-data-opts) for a YANG
  // `module` schema.

  // ```javascript
  // var schema = Yang.parse('module foo { container bar { leaf a { type uint8; } } }');
  // var model = schema.eval({ 'foo:bar': { a: 7 } });
  // // model is { 'foo:bar': [Getter/Setter] }
  // ```

  // The generated `Model` is a hierarchical composition of
  // [Property](./property.litcoffee) instances. The instance itself uses
  // `Object.preventExtensions` to ensure no additional properties that are
  // not known to itself can be added.

  // It is designed to provide *stand-alone* interactions on a per-module
  // basis. For flexible management of multiple modules (such as hotplug
  // modules) and data persistence, please take a look at the
  // [yang-store](http://github.com/corenova/yang-store) project.

  // Below are list of properties available to every instance of `Model`
  // (it also inherits properties from [Property](./property.litcoffee)):

  // property | type | mapping | description
  // --- | --- | --- | ---
  // transactable | boolean | computed | getter/setter for `state.transactable`
  // instance | Emitter | access(state) | holds runtime features

  // ## Dependencies
  var Container,
      Emitter,
      Model,
      Stack,
      Store,
      XPath,
      splice = [].splice;

  Stack = require('stacktrace-parser');

  Emitter = require('events').EventEmitter;

  Store = require('./store');

  Container = require('./container');

  XPath = require('./xpath');

  Model = function () {
    var enqueue;

    // ## Class Model

    var Model = function (_Container) {
      _inherits(Model, _Container);

      function Model() {
        _classCallCheck(this, Model);

        var base;
        // CS2 does not support below
        // unless this instanceof Model then return new Model arguments...

        var _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).apply(this, arguments));

        _this.state.transactable = false;
        _this.state.maxTransactions = 100;
        _this.state.queue = [];
        _this.state.imports = new Map();
        _this.state.store = void 0;
        if (typeof (base = _this.schema).on === "function") {
          base.on('change', function (elem) {
            var props;
            _this.debug('[adaptive] detected schema change at ' + elem.datapath);
            try {
              props = _this.find(elem.datapath);
            } catch (error) {
              props = [];
            }
            return props.forEach(function (prop) {
              return prop.set(prop.content, {
                force: true
              });
            });
          });
        }
        _this.debug('created a new YANG Model: ' + _this.name);
        return _this;
      }

      // ### attach


      _createClass(Model, [{
        key: 'attach',
        value: function attach(obj, parent, opts) {
          var ref;
          if (!(obj instanceof Object)) {
            return this;
          }
          this.store = (ref = parent != null ? parent.store : void 0) != null ? ref : new Store();
          if (!this.attached) {
            this.set(obj, opts);
          }
          this.store.add(this);
          this.state.attached = true;
          return this;
        }

        // ### access (model)

        // This is a unique capability for a Model to be able to access any
        // other arbitrary model present inside the `Model.store`.

      }, {
        key: 'access',
        value: function access(model) {
          var ref;
          return (ref = this.store) != null ? ref.access(model) : void 0;
        }

        // ### save

        // This routine triggers a 'commit' event for listeners to handle any
        // persistence operations. It also clears the `@state.queue` transaction
        // queue so that future [rollback](#rollback) will reset back to this
        // state.

      }, {
        key: 'save',
        value: function save() {
          this.debug("[save] trigger commit and clear queue");
          this.emit('commit', this.state.queue.slice());
          this.state.queue.splice(0, this.state.queue.length);
          return this;
        }

        // ### rollback

        // This routine will replay tracked `@state.queue` in reverse chronological
        // order (most recent -> oldest) when `@transactable` is set to
        // `true`. It will restore the Property instance back to the last known
        // [save](#save-opts) state.

      }, {
        key: 'rollback',
        value: function rollback() {
          var change;
          while (change = this.state.queue.pop()) {
            change.target.set(change.value, {
              suppress: true
            });
          }
          return this;
        }

        // ## Prototype Overrides

        // ### on (event)

        // The `Model` instance registers `@state` as an `EventEmitter` and you
        // can attach various event listeners to handle events generated by the
        // `Model`:

        // event | arguments | description
        // --- | --- | ---
        // update | (prop, prev) | fired when an update takes place within the data tree
        // change | (elems...) | fired when the schema is modified
        // create | (items...) | fired when one or more `list` element is added
        // delete | (items...) | fired when one or more `list` element is deleted

        // It also accepts optional XPATH/YPATH expressions which will *filter*
        // for granular event subscription to specified events from only the
        // elements of interest.

        // The event listeners to the `Model` can handle any customized behavior
        // such as saving to database, updating read-only state, scheduling
        // background tasks, etc.

        // This operation is protected from recursion, where operations by the
        // `callback` may result in the same `callback` being executed multiple
        // times due to subsequent events triggered due to changes to the
        // `Model`. Currently, it will allow the same `callback` to be executed
        // at most two times within the same execution stack.

      }, {
        key: 'emit',
        value: function emit(event) {
          var ref;
          _get(Model.prototype.__proto__ || Object.getPrototypeOf(Model.prototype), 'emit', this).apply(this, arguments);
          if (event !== 'error') {
            var _ref;

            return (ref = this.store) != null ? (_ref = ref).emit.apply(_ref, arguments) : void 0;
          }
        }
      }, {
        key: 'on',
        value: function on(event) {
          var _ref2, _ref3, _splice$call, _splice$call2;

          for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            filters[_key - 1] = arguments[_key];
          }

          var $$$, callback, ctx, recursive, ref;
          ref = filters, (_ref2 = ref, _ref3 = _toArray(_ref2), filters = _ref3.slice(0), _ref2), (_splice$call = splice.call(filters, -1), _splice$call2 = _slicedToArray(_splice$call, 1), callback = _splice$call2[0], _splice$call);
          if (!(callback instanceof Function)) {
            throw new Error("must supply callback function to listen for events");
          }
          recursive = function recursive(name) {
            var callee, column, file, frame, frames, i, j, len, lineNumber, seen;
            seen = {};
            frames = Stack.parse(new Error().stack);
            for (i = j = 0, len = frames.length; j < len; i = ++j) {
              frame = frames[i];
              if (!~frame.methodName.indexOf(name)) {
                continue;
              }
              var _frames = frames[i - 1];
              file = _frames.file;
              lineNumber = _frames.lineNumber;
              column = _frames.column;

              callee = file + ':' + lineNumber + ':' + column;
              if (seen[callee] == null) {
                seen[callee] = 0;
              }
              if (++seen[callee] > 1) {
                console.warn('detected recursion for \'' + callee + '\'');
                return true;
              }
            }
            return false;
          };
          ctx = this.context;
          $$$ = function $$$(prop) {
            var _prop$path;

            if (typeof debug === "function") {
              debug('$$$: check if \'' + prop.path + '\' in \'' + filters + '\'');
            }
            if (!filters.length || (_prop$path = prop.path).contains.apply(_prop$path, _toConsumableArray(filters))) {
              if (!recursive('$$$')) {
                for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }

                return callback.apply(ctx, [prop].concat(args));
              }
            }
          };
          return this.state.on(event, $$$);
        }

        // Please refer to [Model Events](../TUTORIAL.md#model-events) section of
        // the [Getting Started Guide](../TUTORIAL.md) for usage examples.

        // ### find (pattern)

        // This routine enables *cross-model* property search when the `Model` is
        // joined to another object (such as a datastore). The schema-bound model
        // restricts *cross-model* property access to only those modules that are
        // `import` dependencies of the current model instance.

      }, {
        key: 'find',
        value: function find() {
          var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var e, match, ref, target, xpath;
          if (!this.attached) {
            return _get(Model.prototype.__proto__ || Object.getPrototypeOf(Model.prototype), 'find', this).apply(this, arguments);
          }
          this.debug('[find] match ' + pattern + ' (root: ' + opts.root + ')');
          try {
            match = _get(Model.prototype.__proto__ || Object.getPrototypeOf(Model.prototype), 'find', this).call(this, pattern, {
              root: true
            });
          } catch (error) {
            e = error;
            match = [];
          }
          if (match.length || opts.root) {
            return match;
          }
          xpath = function () {
            switch (false) {
              case !(pattern instanceof XPath):
                return pattern;
              default:
                return XPath.parse(pattern, this.schema);
            }
          }.call(this);
          if (xpath.xpath == null) {
            return [];
          }

          var _xpath$xpath$tag$spli = xpath.xpath.tag.split(':');

          var _xpath$xpath$tag$spli2 = _slicedToArray(_xpath$xpath$tag$spli, 1);

          target = _xpath$xpath$tag$spli2[0];

          if (target === this.name) {
            return [];
          }
          // enforce cross-model access only to import dependencies
          if (!((ref = this.schema.import) != null ? ref.some(function (x) {
            return x.tag === target;
          }) : void 0)) {
            return [];
          }
          this.debug('[find] locate ' + target + ' and apply ' + xpath);
          opts.root = true;
          try {
            return this.access(target).find(xpath, opts);
          } catch (error) {}
          try {
            // TODO: below is kind of heavy-handed...
            return this.schema.lookup('module', target).eval(this.content).find(xpath, opts);
          } catch (error) {}
          return [];
        }
      }]);

      return Model;
    }(Container);

    ;

    Model.prototype.logger = require('debug')('yang:model');

    // ### Computed Properties
    enqueue = function enqueue(prop) {
      if (this.queue.length > this.maxTransactions) {
        throw prop.error('exceeded max transaction queue of ' + this.maxTransactions + ', forgot to save()?');
      }
      return this.queue.push({
        target: prop,
        value: prop.state.prev
      });
    };

    Model.property('transactable', {
      enumerable: true,
      get: function get() {
        return this.state.transactable;
      },
      set: function set(toggle) {
        if (toggle === this.state.transactable) {
          return;
        }
        if (toggle === true) {
          this.state.on('update', enqueue);
        } else {
          this.state.removeListener('update', enqueue);
          this.state.queue.splice(0, this.state.queue.length);
        }
        return this.state.transactable = toggle;
      }
    });

    Model.property('store', {
      get: function get() {
        return this.state.store;
      },
      set: function set(store) {
        return this.state.store = store;
      }
    });

    return Model;
  }.call(this);

  // ## Export Model Class
  module.exports = Model;
}).call(undefined);

},{"./container":1,"./store":15,"./xpath":17,"debug":25,"events":28,"stacktrace-parser":36}],13:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Container, Notification;

  Container = require('./container');

  Notification = function () {
    var Notification = function (_Container) {
      _inherits(Notification, _Container);

      function Notification() {
        _classCallCheck(this, Notification);

        return _possibleConstructorReturn(this, (Notification.__proto__ || Object.getPrototypeOf(Notification)).apply(this, arguments));
      }

      _createClass(Notification, [{
        key: 'merge',
        value: function merge(value, opts) {
          return this.set(value, opts);
        }
      }]);

      return Notification;
    }(Container);

    ;

    Notification.prototype.logger = require('debug')('yang:notification');

    return Notification;
  }.call(this);

  module.exports = Notification;
}).call(undefined);

},{"./container":1,"debug":25}],14:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Property - controller of Object properties

  // The `Property` class is the *secretive shadowy* element that governs
  // `Object` behavior and are bound to the `Object` via
  // `Object.defineProperty`. It acts like a shadow `Proxy/Reflector` to
  // the `Object` instance and provides tight control via the
  // `Getter/Setter` interfaces.

  // Below are list of properties available to every instance of `Property`:

  // property | type | mapping | description
  // --- | --- | --- | ---
  // name   | string | direct | name of the property
  // schema | object | direct | a schema instance (usually [Yang](./src/yang.listcoffee))
  // state  | object | direct | *private* object holding internal state
  // configurable | boolean | getter(state) | defines whether this property can be redefined
  // enumerable   | boolean | getter(state) | defines whether this property is enumerable
  // content | any | computed | getter/setter for `state.value`
  // context | object | computed | dynamically generated using [context](./src/context.coffee)
  // root  | [Property](./src/property.litcoffee) | computed | dynamically returns the root Property instance
  // path  | [XPath](./src/xpath.coffee) | computed | dynamically generate XPath for this Property from root

  // ## Class Property
  var Property, XPath, Yang, context, _debug, delegate;

  _debug = require('debug');

  delegate = require('delegates');

  context = require('./context');

  Yang = require('./yang');

  XPath = require('./xpath');

  Property = function () {
    var Property = function () {
      _createClass(Property, [{
        key: 'debug',
        value: function debug(f) {
          switch (false) {
            case !_debug.enabled(this.logger.namespace):
              switch (false) {
                case typeof f !== 'function':
                  return this.logger.apply(this, [this.uri].concat(_toConsumableArray([].concat(f()))));
                default:
                  return this.logger.apply(this, [this.uri].concat(Array.prototype.slice.call(arguments)));
              }
          }
        }
      }], [{
        key: 'property',
        value: function property(prop, desc) {
          return Object.defineProperty(this.prototype, prop, desc);
        }
      }]);

      function Property() {
        var spec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Property);

        var name, schema;
        if (typeof spec === 'string') {
          // NOTE: ES6/CS2 does not support below
          // unless this instanceof Property then return new Property arguments...

          // 1. parse if spec is YANG definition (string)
          spec = Yang.parse(spec);
        }
        if (spec instanceof Yang) {

          // 2. assign if spec is an instance of Yang schema
          schema = spec;
        }
        if (schema == null) {
          var _spec = spec;

          // 3. destructure spec as an object if not schema as instance

          name = _spec.name;
          schema = _spec.schema;
        }
        if (typeof schema === 'string') {

          // 4. parse if schema is YANG definition (string)
          schema = Yang.parse(schema);
        }
        if (schema == null) {
          schema = {
            kind: 'anydata'
          };
        }
        // 5. initialize property instance
        this.name = name != null ? name : schema.datakey;
        this.schema = schema;
        this.state = {
          strict: false,
          private: false,
          mutable: schema.config != false,
          attached: false,
          replaced: false,
          changed: false,
          locked: false,
          prior: void 0,
          value: void 0,
          parent: null
        };
        // 6. soft freeze this instance
        Object.preventExtensions(this);
      }

      // ## Instance-level methods


      _createClass(Property, [{
        key: 'clone',
        value: function clone() {
          var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var copy;
          if ((typeof state === 'undefined' ? 'undefined' : _typeof(state)) !== 'object') {
            throw this.error('must clone with state typeof object');
          }
          copy = new this.constructor(this);
          copy.state = Object.assign(Object.create(this.state), state, {
            origin: this
          });
          return copy;
        }
      }, {
        key: 'equals',
        value: function equals(a, b) {
          switch (this.kind) {
            case 'leaf-list':
              if (!(a && b)) {
                return false;
              }
              a = Array.from(new Set([].concat(a)));
              b = Array.from(new Set([].concat(b)));
              if (a.length !== b.length) {
                return false;
              }
              return a.every(function (x) {
                return b.some(function (y) {
                  return x === y;
                });
              });
            default:
              return a === b;
          }
        }

        // ### get (key)

        // This is the main `Getter` for the target object's property value. When
        // called with optional `key` it will perform an internal
        // [find](#find-xpath) operation to traverse/locate that value being
        // requested instead of returning its own `@data`.

        // It also provides special handling based on different types of
        // `@data` currently held.

      }, {
        key: 'get',
        value: function get(key) {
          var match;
          switch (false) {
            case key == null:
              try {
                match = this.find(key);
              } catch (error) {}
              if (!(match != null && match.length)) {
                return;
              }
              switch (false) {
                case match.length !== 1:
                  return match[0].data;
                case !(match.length > 1):
                  return match.map(function (x) {
                    return x.data;
                  });
                default:
                  return void 0;
              }
              break;
            default:
              return this.data;
          }
        }

        // ### set (value)

        // This is the main `Setter` for the target object's property value.  It
        // utilizes internal `@schema` attribute if available to enforce schema
        // validations.

      }, {
        key: 'set',
        value: function set(value) {
          var _this = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var bypass, e, ref, ref1, subopts;
          if (opts.origin == null) {
            opts.origin = this;
          }

          // @debug => "[set] enter..."
          if (!(this.mutable || value == null || opts.force)) {
            throw this.error("cannot set data on read-only (config false) element", 'set');
          }
          try {
            if (((ref = this.binding) != null ? ref.set : void 0) != null) {
              value = this.binding.set(this.context.with(opts), value);
            }
          } catch (error) {
            e = error;
            throw this.error(e, 'set');
          }
          if (value != null && this.equals(value, this.value)) {
            // return if same value
            return this;
          }
          bypass = opts.bypass && ((ref1 = this.kind) === "leaf" || ref1 === "leaf-list");
          this.debug(function () {
            return "[set] applying schema...";
          });
          value = function () {
            switch (false) {
              case !(this.schema.apply != null && !bypass):
                subopts = Object.assign({}, opts, {
                  inner: true
                });
                try {
                  return this.schema.apply(value, this, subopts);
                } catch (error) {
                  e = error;
                  throw this.error(e, 'set');
                }
                break;
              default:
                return value;
            }
          }.call(this);
          this.debug(function () {
            return "[set] done applying schema...";
          });
          if (value instanceof Error) {
            return this;
          }
          if (value != null && this.equals(value, this.value)) {
            // return if same value
            return this;
          }
          this.debug(function () {
            return '[set] replaced? ' + (_this.state.value != null);
          });
          this.state.replaced = this.state.prior != null || this.state.value != null;
          return this.update(value, opts);
        }

        // ### merge (value)

        // Performs a granular merge of `value` into existing `@value` if
        // available, otherwise performs [set](#set-value) operation.

      }, {
        key: 'merge',
        value: function merge(value) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (opts.origin == null) {
            opts.origin = this;
          }
          if (value === null) {
            return this.delete(opts);
          }
          return this.set(value, opts);
        }

        // ### delete

      }, {
        key: 'delete',
        value: function _delete() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var e, ref;
          if (opts.origin == null) {
            opts.origin = this;
          }
          if (this.state.value == null) {
            //return this if @state.value is null
            return this;
          }
          if (!opts.force && ((ref = this.binding) != null ? ref.delete : void 0) != null) {
            try {
              this.binding.delete(this.context.with(opts), null);
            } catch (error) {
              e = error;
              throw this.error(e, 'delete');
            }
          }
          this.state.replaced = this.state.prior != null; // revisit if we need to do this
          return this.update(null, opts);
        }

        // ### update

        // Updates the value to the data model. Called *once* for each node that
        // is part of the change branch.

      }, {
        key: 'update',
        value: function update(value) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var base, ref;
          if (opts.origin == null) {
            opts.origin = this;
          }
          (base = this.state).changed || (base.changed = this.state.value !== value);
          this.state.value = value;
          if ((ref = this.parent) != null) {
            ref.update(this, opts);
          }
          return this;
        }

        // ### commit async transaction

        // Commits the changes to the data model. Called *once* for each node that
        // is part of the change branch.

      }, {
        key: 'lock',
        value: function lock() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.state.locked = true;
          this.state.delta = this.change;
          opts.lock = this;
          return this;
        }
      }, {
        key: 'unlock',
        value: function unlock() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.state.locked = false;
          // @state.delta = undefined
          delete opts.lock;
          return this;
        }
      }, {
        key: 'commit',
        value: async function commit() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var err, ref, ref1, ref2;
          if (!this.changed) {
            return this;
          }
          try {
            await this.lock(opts);

            // 1. perform the bound commit transaction
            if (!opts.sync && ((ref = this.binding) != null ? ref.commit : void 0) != null) {
              this.debug(function () {
                return "[commit] execute commit binding...";
              });
              await ((ref1 = this.binding) != null ? typeof ref1.commit === "function" ? ref1.commit(this.context.with(opts)) : void 0 : void 0);
            }
            if (!opts.inner) {
              // 2. wait for the parent to commit unless called by parent
              await ((ref2 = this.parent) != null ? typeof ref2.commit === "function" ? ref2.commit(opts) : void 0 : void 0);
            }
            if (this.parent == null) {
              // 3. self-clean only if no parent
              this.clean(opts);
            }
          } catch (error) {
            err = error;
            this.debug(function () {
              return '[commit] revert due to ' + err.message;
            });
            await this.revert(opts);
            throw this.error(err, 'commit');
          } finally {
            this.unlock(opts);
          }
          return this;
        }
      }, {
        key: 'revert',
        value: async function revert() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          var err, id, ref, temp;
          if (!this.changed) {
            return;
          }
          id = opts.seq;
          this.debug('[revert:' + id + '] changing back from:', this.state.value);
          this.debug('[revert:' + id + '] changing back to:', this.state.prior);
          temp = this.state.value;
          this.state.value = this.state.prior;
          this.state.prior = temp; // preserve what we were trying to change to within commit context
          if (!opts.sync) {
            this.debug('[revert:' + id + '] execute binding...');
          }
          try {
            if (!opts.sync) {
              await ((ref = this.binding) != null ? typeof ref.commit === "function" ? ref.commit(this.context.with(opts)) : void 0 : void 0);
            }
          } catch (error) {
            err = error;
            this.debug('[revert:' + id + '] failed due to: ' + err.message);
          }
          // throw @error err, 'revert'
          this.debug('[revert:' + id + '] cleaning up...');
          return this.clean(opts);
        }
      }, {
        key: 'clean',
        value: function clean() {
          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          // @state.prior = @state.value # save current value as prior
          this.state.prior = this.toJSON(); // save copy of current data as prior
          this.state.changed = false;
          this.state.replaced = false;
          return this.debug('[clean:' + opts.seq + '] finalized commit, persisted:', this.state.prior);
        }

        // ### attach (obj, parent, opts)

        // This call is the primary mechanism via which the `Property` instance
        // attaches itself to the provided target `obj`. It defines itself in the
        // target `obj` via `Object.defineProperty`.

      }, {
        key: 'attach',
        value: function attach(obj, parent, opts) {
          var _this2 = this;

          var name;
          if (!(obj instanceof Object)) {
            return obj;
          }
          if (opts == null) {
            opts = {
              replace: false,
              force: false
            };
          }
          this.parent = parent;
          // if joining for the first time, apply existing data unless explicit replace
          if (!this.attached) {
            // @debug "[attach] applying existing data for #{@name} (external: #{@external}) to:"
            // @debug obj
            name = function () {
              var ref;
              switch (false) {
                case !(((ref = this.parent) != null ? ref.external : void 0) && this.tag in obj):
                  return this.tag;
                case !this.external:
                  return this.name;
                case !(this.name in obj):
                  return this.name;
                default:
                  return this.root.name + ':' + this.name;
              }
            }.call(this);
            this.set(obj[name], Object.assign({}, opts, {
              inner: true
            }));
          }
          if (!opts.preserve) {
            try {
              Object.defineProperty(obj, this.name, {
                configurable: true,
                enumerable: this.enumerable,
                get: function get() {
                  return _this2.get.apply(_this2, arguments);
                },
                set: function set() {
                  return _this2.set.apply(_this2, arguments);
                }
              });
            } catch (error) {}
          }
          this.state.attached = true;
          this.debug(function () {
            return '[attach] attached into ' + obj.constructor.name + ' container';
          });
          return obj;
        }

        // ### find (pattern)

        // This helper routine can be used to allow traversal to other elements
        // in the data tree from the relative location of the current `Property`
        // instance. It returns matching `Property` instances based on the
        // provided `pattern` in the form of XPATH or YPATH.

        // It is internally used via [get](#get) and generally used inside
        // controller logic bound inside the [Yang expression](./yang.litcoffee)
        // as well as event handler listening on [Model](./model.litcoffee)
        // events.

        // It *always* returns an array (empty to denote no match) unless it
        // encounters an error, in which case it will throw an Error.

      }, {
        key: 'find',
        value: function find() {
          var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.';
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var ref, ref1;
          this.debug(function () {
            return '[find] ' + pattern;
          });
          pattern = XPath.parse(pattern, this.schema);
          switch (false) {
            case !(pattern.tag === '/' && this !== this.root):
              return this.root.find(pattern);
            case pattern.tag !== '..':
              return (ref = this.parent) != null ? ref.find(pattern.xpath) : void 0;
            default:
              return (ref1 = pattern.apply(this)) != null ? ref1 : [];
          }
        }

        // ### in (pattern)

        // A convenience routine to locate one or more matching Property
        // instances based on `pattern` (XPATH or YPATH) from this Model.

      }, {
        key: 'in',
        value: function _in(pattern) {
          var props;
          try {
            props = this.find(pattern);
          } catch (error) {}
          if (!(props != null && props.length)) {
            return;
          }
          switch (false) {
            case !(props.length > 1):
              return props;
            default:
              return props[0];
          }
        }

        // ### defer (value)

        // Optionally defer setting the value to the property until root has been updated.

      }, {
        key: 'defer',
        value: function defer(value) {
          var _this3 = this;

          this.debug(function () {
            return 'deferring \'' + _this3.kind + '(' + _this3.name + ')\' until update at ' + _this3.root.name;
          });
          this.root.once('update', function () {
            _this3.debug(function () {
              return 'applying deferred data (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ')';
            });
            return _this3.data = value;
          });
          return value;
        }

        // ### error (msg)

        // Provides more contextual error message pertaining to the Property instance.

      }, {
        key: 'error',
        value: function error(err, ctx) {
          var ref;
          if (!(err instanceof Error)) {
            err = new Error(err);
          }
          if (err.uri == null) {
            err.uri = this.uri;
          }
          if (err.src == null) {
            err.src = this;
          }
          if (err.ctx == null) {
            err.ctx = ctx;
          }
          switch (false) {
            case ((ref = this.binding) != null ? ref.error : void 0) == null:
              return this.binding.error(err);
            default:
              return err;
          }
        }

        // ### toJSON

        // This call creates a new copy of the current `Property.content`
        // completely detached/unbound to the underlying data schema. It's main
        // utility is to represent the current data state for subsequent
        // serialization/transmission. It accepts optional argument `tag` which
        // when called with `true` will tag the produced object with the current
        // property's `@name`.

      }, {
        key: 'toJSON',
        value: function toJSON(key) {
          var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var value;
          value = function () {
            switch (false) {
              case this.kind !== 'anydata':
                return void 0;
              case !(state !== true && !this.mutable):
                return void 0;
              default:
                return this.data;
            }
          }.call(this);
          if (key === true) {
            value = _defineProperty({}, '' + this.name, value);
          }
          return value;
        }

        // ### inspect

      }, {
        key: 'inspect',
        value: function inspect() {
          return {
            name: this.name,
            kind: this.kind,
            path: this.path.toString(),
            active: this.active,
            private: this.private,
            mutable: this.mutable,
            changed: this.changed,
            schema: function () {
              var ref;
              switch (false) {
                case this.schema.uri == null:
                  return {
                    uri: this.schema.uri,
                    summary: (ref = this.schema.description) != null ? ref.tag : void 0,
                    datakey: this.schema.datakey,
                    datapath: this.schema.datapath,
                    external: this.schema.external,
                    children: this.schema.children.map(function (x) {
                      return x.uri;
                    })
                  };
                default:
                  return false;
              }
            }.call(this),
            value: this.toJSON()
          };
        }
      }]);

      return Property;
    }();

    ;

    Property.prototype.logger = _debug('yang:property');

    delegate(Property.prototype, 'state').access('parent').access('strict').getter('private').getter('mutable').getter('attached').getter('replaced').getter('changed').getter('locked').getter('prior').getter('value');

    delegate(Property.prototype, 'schema').getter('tag').getter('kind').getter('type').getter('default').getter('external').getter('binding').method('locate').method('lookup');

    // ### Computed Properties
    Property.property('key', {
      get: function get() {
        return this.name;
      }
    });

    Property.property('value', {
      get: function get() {
        return this.state.value;
      }
    });

    Property.property('data', {
      set: function set(value) {
        return this.set(value, {
          force: true
        });
      },
      get: function get() {
        var ref;
        switch (false) {
          case ((ref = this.binding) != null ? ref.get : void 0) == null:
            return this.binding.get(this.context);
          default:
            return this.value;
        }
      }
    });

    Property.property('enumerable', {
      get: function get() {
        return !this.private && (this.value != null || this.binding != null);
      }
    });

    Property.property('active', {
      get: function get() {
        return this.enumerable && this.value != null;
      }
    });

    Property.property('change', {
      get: function get() {
        switch (false) {
          case !(this.changed && !this.active):
            return null;
          case !this.changed:
            return this.data;
        }
      }
    });

    Property.property('context', {
      get: function get() {
        var ctx;
        ctx = Object.create(context);
        ctx.opts = {};
        ctx.node = this;
        Object.preventExtensions(ctx);
        return ctx;
      }
    });

    Property.property('root', {
      get: function get() {
        var root;
        if (this.kind === 'module') {
          return this;
        }
        root = function () {
          switch (false) {
            case this.parent !== this:
              return this;
            case !(this.parent instanceof Property):
              return this.parent.root;
            default:
              return this;
          }
        }.call(this);
        if (this.state.root !== root) {
          this.state.path = void 0;
        }
        return this.state.root = root;
      }
    });

    Property.property('path', {
      get: function get() {
        var base, entity;
        if (this === this.root) {
          entity = function () {
            switch (false) {
              case this.kind !== 'module':
                return '/';
              default:
                return '.';
            }
          }.call(this);
          return XPath.parse(entity, this.schema);
        }
        if ((base = this.state).path == null) {
          base.path = this.parent.path.clone().append(this.key);
        }
        return this.state.path;
      }
    });

    Property.property('uri', {
      get: function get() {
        var ref;
        switch (false) {
          case !(this.parent != null && this.parent.uri != null):
            return this.parent.uri + '/' + this.key;
          case this.parent == null:
            return this.key;
          default:
            return (ref = this.schema.datapath) != null ? ref : this.schema.uri;
        }
      }
    });

    return Property;
  }.call(this);

  // ## Export Property Class
  module.exports = Property;
}).call(undefined);

},{"./context":2,"./xpath":17,"./yang":18,"debug":25,"delegates":27}],15:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Container, Store, delegate;

  delegate = require('delegates');

  Container = require('./container');

  Store = function () {
    var Store = function (_Container) {
      _inherits(Store, _Container);

      function Store() {
        _classCallCheck(this, Store);

        var _this = _possibleConstructorReturn(this, (Store.__proto__ || Object.getPrototypeOf(Store)).apply(this, arguments));
        // CS2 does not support below
        // unless this instanceof Store then return new Store arguments...


        _this.state.schemas = new Set();
        _this.state.models = new Map();
        return _this;
      }

      _createClass(Store, [{
        key: 'use',
        value: function use() {
          var _this2 = this;

          for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
            schemas[_key] = arguments[_key];
          }

          schemas.filter(function (s) {
            return s.kind === 'module';
          }).forEach(function (s) {
            return _this2.schemas.add(s);
          });
          return this;
        }
      }, {
        key: 'add',
        value: function add() {
          var _this3 = this;

          for (var _len2 = arguments.length, models = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            models[_key2] = arguments[_key2];
          }

          models.filter(function (m) {
            return m.kind === 'module';
          }).forEach(function (m) {
            m.on('error', _this3.emit.bind(_this3, 'error'));
            return _this3.models.set(m.name, m);
          });
          return this;
        }
      }, {
        key: 'access',
        value: function access(model) {
          if (!this.models.has(model)) {
            throw this.error('unable to locate \'' + model + '\' instance in the Store');
          }
          return this.models.get(model);
        }
      }, {
        key: 'set',
        value: function set(data) {
          var _this4 = this;

          this.models.clear();
          this.schemas.forEach(function (s) {
            return s.eval(data, _this4);
          });
          return this;
        }
      }, {
        key: 'find',
        value: function find(pattern, opts) {
          var i, key, match, v, value;
          i = this.models.entries();
          while (v = i.next(), !v.done) {
            var _v$value = _slicedToArray(v.value, 2);

            key = _v$value[0];
            value = _v$value[1];

            match = value.find(pattern, opts);
            if (match.length) {
              return match;
            }
          }
          return [];
        }
      }, {
        key: 'toJSON',
        value: function toJSON(key) {
          var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          var i, k, model, name, obj, ref, v;
          obj = {};
          i = this.models.entries();
          while (v = i.next(), !v.done) {
            var _v$value2 = _slicedToArray(v.value, 2);

            name = _v$value2[0];
            model = _v$value2[1];

            if (model == null) {
              continue;
            }
            ref = model.toJSON(false, state);
            for (k in ref) {
              v = ref[k];
              obj[k] = v;
            }
          }
          return obj;
        }
      }]);

      return Store;
    }(Container);

    ;

    Store.prototype.logger = require('debug')('yang:store');

    delegate(Store.prototype, 'state').getter('schemas').getter('models');

    delegate(Store.prototype, 'models').method('has');

    Store.property('store', {
      get: function get() {
        return this;
      }
    });

    return Store;
  }.call(this);

  module.exports = Store;
}).call(undefined);

},{"./container":1,"debug":25,"delegates":27}],16:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Expression, Typedef;

  Expression = require('./expression');

  Typedef = function () {
    var Typedef = function (_Expression) {
      _inherits(Typedef, _Expression);

      function Typedef() {
        var _ref;

        _classCallCheck(this, Typedef);

        return _possibleConstructorReturn(this, (_ref = Typedef.__proto__ || Object.getPrototypeOf(Typedef)).call.apply(_ref, [this, 'typedef'].concat(Array.prototype.slice.call(arguments))));
      }

      return Typedef;
    }(Expression);

    ;

    Typedef.prototype.logger = require('debug')('yang:typedef');

    Typedef.property('basetype', {
      get: function get() {
        return this.tag;
      }
    });

    Typedef.property('convert', {
      get: function get() {
        var ref;
        return (ref = this.construct) != null ? ref : function (x) {
          return x;
        };
      }
    });

    return Typedef;
  }.call(this);

  module.exports = Typedef;
}).call(undefined);

},{"./expression":4,"debug":25}],17:[function(require,module,exports){
'use strict';

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  var Expression, Filter, XPath, exports, xparse;

  Expression = require('./expression');

  xparse = require('xparse');

  Filter = function () {
    var Filter = function (_Expression) {
      _inherits(Filter, _Expression);

      function Filter() {
        var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        _classCallCheck(this, Filter);

        var source;
        source = {
          argument: 'predicate',
          scope: {},
          transform: function transform(prop) {
            var expr, props;
            expr = this.tag;
            switch (typeof expr === 'undefined' ? 'undefined' : _typeof(expr)) {
              case 'number':
                return prop.props[expr - 1];
              case 'string':
                return prop.children.get('key(' + expr + ')');
              default:
                props = function () {
                  switch (false) {
                    case prop.kind !== 'list':
                      return prop.props;
                    default:
                      return [prop];
                  }
                }();
                return props.filter(function (prop) {
                  return expr(function (name, arg) {
                    var elem;
                    elem = prop.data;
                    if (arg == null) {
                      return elem[name];
                    }
                    switch (name) {
                      case 'current':
                        return elem;
                      case 'false':
                        return false;
                      case 'true':
                        return true;
                      case 'key':
                        return arg;
                      case 'name':
                        return elem[arg];
                    }
                  });
                });
            }
          }
        };

        var _this = _possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this, 'filter', xparse(pattern), source));

        _this.pattern = pattern;
        return _this;
      }

      _createClass(Filter, [{
        key: 'clone',
        value: function clone() {
          return new this.constructor(this.pattern);
        }
      }, {
        key: 'toString',
        value: function toString() {
          return this.pattern;
        }
      }]);

      return Filter;
    }(Expression);

    ;

    Filter.prototype.logger = require('debug')('yang:xpath:filter');

    return Filter;
  }.call(this);

  XPath = function () {
    var XPath = function (_Expression2) {
      _inherits(XPath, _Expression2);

      _createClass(XPath, null, [{
        key: 'split',
        value: function split(pattern) {
          var elements;
          elements = pattern.match(/([^\/^\[]*(?:\[.+?\])*)/g);
          if (elements == null) {
            elements = [];
          }
          elements = elements.filter(function (x) {
            return !!x;
          });
          return elements;
        }
      }]);

      function XPath(pattern, schema) {
        _classCallCheck(this, XPath);

        var e, elements, match, predicates, source, target;
        if (pattern instanceof XPath) {
          var _ret;

          return _ret = pattern, _possibleConstructorReturn(_this2, _ret);
        }
        if (typeof pattern !== 'string') {
          throw new Error("must pass in 'pattern' as valid string");
        }
        elements = XPath.split(pattern);
        if (/^\//.test(pattern)) {
          target = '/';
          if (schema instanceof Expression) {
            schema = schema.root;
          }
          predicates = [];
        } else {
          if (!(elements.length > 0)) {
            throw new Error('unable to process \'' + pattern + '\' (please check your input)');
          }

          var _elements$shift$split = elements.shift().split(/\[\s*(.+?)\s*\]/);

          var _elements$shift$split2 = _toArray(_elements$shift$split);

          target = _elements$shift$split2[0];
          predicates = _elements$shift$split2.slice(1);

          if (target == null) {
            throw new Error('unable to process \'' + pattern + '\' (missing axis)');
          }
          predicates = predicates.filter(function (x) {
            return !!x;
          });
          if (schema instanceof Expression) {
            try {
              match = schema.locate(target);
            } catch (error) {
              e = error;
              console.warn(e);
            }
            if (match == null) {
              switch (schema.kind) {
                case 'list':
                  predicates.unshift(function () {
                    switch (false) {
                      case schema.key == null:
                        return '\'' + target + '\'';
                      default:
                        return target;
                    }
                  }());
                  target = '.';
                  break;
                case 'anydata':
                  schema = void 0;
                  break;
                default:
                  throw new Error('unable to locate \'' + target + '\' inside schema: ' + schema.uri);
              }
            } else {
              schema = match;
              if (!/^\./.test(target)) {
                target = schema.datakey;
              }
            }
          }
        }
        source = {
          argument: 'node',
          scope: {
            filter: '0..n',
            xpath: '0..1'
          },
          transform: function transform(data) {
            return this.process(data);
          }
        };

        var _this2 = _possibleConstructorReturn(this, (XPath.__proto__ || Object.getPrototypeOf(XPath)).call(this, 'xpath', target, source));

        if (schema instanceof Expression) {
          Object.defineProperty(_this2, 'schema', {
            value: schema
          });
        }
        if (predicates.length > 0) {
          _this2.extends.apply(_this2, _toConsumableArray(predicates.map(function (x) {
            return new Filter(x);
          })));
        }
        if (elements.length > 0) {
          _this2.extends(elements.join('/'));
        }
        return _this2;
      }

      _createClass(XPath, [{
        key: 'process',
        value: function process(data) {
          var _this3 = this;

          var ref, ref1;
          this.debug('[' + this.tag + '] process using schema from ' + ((ref = this.schema) != null ? ref.kind : void 0) + ':' + ((ref1 = this.schema) != null ? ref1.tag : void 0));
          if (!(data instanceof Object)) {
            return [];
          }
          // 1. find all matching props
          data = [].concat(data);
          data = data.reduce(function (a, prop) {
            return a.concat(_this3.match(prop));
          }, []);
          if (this.xpath != null && data.length) {
            return this.xpath.eval(data);
          }
          this.debug('[' + this.tag + '] returning ' + data.length + ' properties');
          // @debug data
          return data;
        }
      }, {
        key: 'match',
        value: function match(prop) {
          var expr, i, len, ref, result;
          // console.warn('MATCH', @tag, prop.children);
          result = function () {
            var _this4 = this;

            switch (false) {
              case this.tag !== '/':
                return prop.root;
              case this.tag !== '.':
                return prop;
              case this.tag !== '..':
                return prop.parent;
              case this.tag !== '*':
                return prop.props;
              case !prop.children.has(this.tag):
                return prop.children.get(this.tag);
              case prop.kind !== 'list':
                return prop.props.map(function (li) {
                  return li.children.get(_this4.tag);
                });
              case this.schema == null:
                return prop.children.get(this.schema.datakey);
            }
          }.call(this);
          result = [].concat(result).filter(Boolean);
          if (this.filter != null) {
            ref = this.filter;
            for (i = 0, len = ref.length; i < len; i++) {
              expr = ref[i];
              if (!result.length) {
                break;
              }
              result = result.reduce(function (a, b) {
                return a.concat(expr.eval(b)).filter(Boolean);
              }, []);
            }
          }
          return result;
        }
      }, {
        key: 'clone',
        value: function clone() {
          var ref, schema;
          schema = this.tag === '/' ? this.schema : (ref = this.parent) != null ? ref.schema : void 0;
          return new this.constructor(this.tag, schema).extends(this.exprs.map(function (x) {
            return x.clone();
          }));
        }
      }, {
        key: 'merge',
        value: function merge(elem) {
          elem = function () {
            switch (false) {
              case !(elem instanceof Expression):
                return elem;
              default:
                return new XPath(elem, this.schema);
            }
          }.call(this);
          if (elem.tag === '.') {
            this.extends(elem.filter, elem.xpath);
            return this;
          } else {
            return _get(XPath.prototype.__proto__ || Object.getPrototypeOf(XPath.prototype), 'merge', this).call(this, elem);
          }
        }

        // returns the XPATH instance found matching the `pattern`

      }, {
        key: 'locate',
        value: function locate(pattern) {
          try {
            if (!(pattern instanceof XPath)) {
              pattern = new XPath(pattern, this.schema);
            }
            if (this.tag !== pattern.tag) {
              return;
            }
            if (!(pattern.filter == null || '' + this.filter === '' + pattern.filter)) {
              return;
            }
            switch (false) {
              case !(this.xpath != null && pattern.xpath != null):
                return this.xpath.locate(pattern.xpath);
              case pattern.xpath == null:
                return void 0;
              default:
                return this;
            }
          } catch (error) {}
        }

        // trims the current XPATH expressions after matching `pattern`

      }, {
        key: 'trim',
        value: function trim(pattern) {
          var match;
          match = this.locate(pattern);
          if (match != null) {
            delete match.xpath;
          }
          return this;
        }

        // append a new pattern at the tail of the current XPATH expression

      }, {
        key: 'append',
        value: function append(pattern) {
          this.tail.merge(pattern);
          return this;
        }

        // returns the XPATH `pattern` that matches part or all of this XPATH instance

      }, {
        key: 'contains',
        value: function contains() {
          var i, len, pattern;

          for (var _len = arguments.length, patterns = Array(_len), _key = 0; _key < _len; _key++) {
            patterns[_key] = arguments[_key];
          }

          for (i = 0, len = patterns.length; i < len; i++) {
            pattern = patterns[i];
            if (this.locate(pattern) != null) {
              return pattern;
            }
          }
        }
      }, {
        key: 'toString',
        value: function toString() {
          var filter, i, len, ref, s;
          s = this.tag === '/' ? '' : this.tag;
          if (this.filter != null) {
            ref = this.filter;
            for (i = 0, len = ref.length; i < len; i++) {
              filter = ref[i];
              s += '[' + filter + ']';
            }
          }
          if (this.xpath != null) {
            s += '/' + this.xpath;
          }
          if (!s) {
            s = this.tag;
          }
          return s;
        }
      }]);

      return XPath;
    }(Expression);

    ;

    XPath.prototype.logger = require('debug')('yang:xpath');

    XPath.property('tail', {
      get: function get() {
        var end;
        end = this;
        while (end.xpath != null) {
          end = end.xpath;
        }
        return end;
      }
    });

    return XPath;
  }.call(this);

  exports = module.exports = XPath;

  exports.Filter = Filter;

  exports.parse = function (pattern, schema) {
    return new XPath(pattern, schema);
  };
}).call(undefined);

},{"./expression":4,"debug":25,"xparse":37}],18:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Generated by CoffeeScript 2.5.1
(function () {
  // # Yang - evaluable schema expression

  // This module provides support for basic set of YANG schema modeling
  // language by using the built-in *extension* syntax to define additional
  // schema language constructs. The actual YANG language [RFC
  // 6020](http://tools.ietf.org/html/rfc6020) specifications are loaded
  // inside the [main module](./main.coffee).

  // This module is the **primary interface** for consumers of this
  // library.

  // ## Dependencies
  var Expression,
      Extension,
      XPath,
      Yang,
      indent,
      parser,
      splice = [].splice;

  parser = require('yang-parser');

  indent = require('indent-string');

  Expression = require('./expression');

  Extension = require('./extension');

  XPath = require('./xpath');

  Yang = function () {
    // ## Class Yang
    var Yang = function (_Expression) {
      _inherits(Yang, _Expression);

      function Yang() {
        _classCallCheck(this, Yang);

        return _possibleConstructorReturn(this, (Yang.__proto__ || Object.getPrototypeOf(Yang)).apply(this, arguments));
      }

      _createClass(Yang, [{
        key: 'emit',
        value: function emit(event) {
          var _emitter;

          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          (_emitter = this.emitter).emit.apply(_emitter, arguments);
          if (event === 'change' && this !== this.root) {
            return this.root.emit(event, this);
          }
        }

        // ## Instance-level methods

        // ### compile (obj)

      }, {
        key: 'compile',
        value: function compile() {
          var _this2 = this;

          if (!(this.source instanceof Expression)) {
            this.debug(function () {
              return _this2.source;
            });
            throw this.error('encountered unknown extension \'' + this.kind + '\'');
          }
          return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'compile', this).apply(this, arguments);
        }

        // ### bind (obj)

        // Every instance of `Yang` expression can be *bound* with control logic
        // which will be used during [eval](#eval-data-opts) to produce schema
        // infused **adaptive data object**. This routine is *inherited* from
        // [Class Expression](./expression.coffee).

        // This facility can be used to associate default behaviors for any
        // element in the configuration tree, as well as handler logic for
        // various YANG statements such as *rpc*, *feature*, etc.

        // This call will return the original `Yang` expression instance with the
        // new bindings registered within the `Yang` expression hierarchy.

      }, {
        key: 'bind',
        value: function bind(data) {
          var binding, e, key;
          if (!this.data && (this.kind === 'module' || this.nodes.length > 0) && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            for (key in data) {
              binding = data[key];
              try {
                this.locate(key).bind(binding);
              } catch (error) {
                e = error;
                if (e.name === 'ExpressionError') {
                  throw e;
                }
                throw this.error('failed to bind to \'' + key + '\' (schema-path not found)', e);
              }
            }
          } else {
            _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'bind', this).call(this, data);
          }
          return this;
        }

        // Please refer to [Schema Binding](../TUTORIAL.md#schema-binding)
        // section of the [Getting Started Guide](../TUTORIAL.md) for usage
        // examples.

        // ### eval (data, opts={})

        // Every instance of `Yang` expression can be [eval](#eval-data-opts)
        // with arbitrary JS data input which will apply the schema against the
        // provided data and return a schema infused **adaptive** data object.

        // This is an extremely useful construct which brings out the true power
        // of YANG for defining and governing arbitrary JS data structures.

        // Basically, the input `data` will be YANG schema validated and
        // converted to a schema infused *adaptive data model* that dynamically
        // defines properties according to the schema expressions.

        // It currently supports the `opts.adaptive` parameter (default `false`)
        // which establishes a persistent binding relationship with the governing
        // `Yang` expression instance. This allows the generated model to
        // dynamically **adapt** to any changes to the governing `Yang`
        // expression instance. Refer to below [extends](#extends-schema) section
        // for additional info on how the schema can be programmatically
        // modified.

      }, {
        key: 'eval',
        value: function _eval(data, ctx) {
          var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          if (opts.adaptive === true) {
            // TODO: this will break for 'module' which will return Model?
            this.once('change', arguments.callee.bind(this, data, opts));
          }
          return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'eval', this).apply(this, arguments);
        }

        // Please refer to [Working with Models](../TUTORIAL.md#working-with-models)
        // section of the [Getting Started Guide](../TUTORIAL.md) for special
        // usage examples for `module` schemas.

        // ### override (callback)

        // Perform schema source extension override to dynamically alter the
        // handling/behavior of the current schema element.

      }, {
        key: 'override',
        value: function override(callback) {
          var argument, construct, resolve, scope, transform;
          var _source = this.source;
          argument = _source.argument;
          scope = _source.scope;
          resolve = _source.resolve;
          transform = _source.transform;
          construct = _source.construct;

          return this.source = new Extension(this.kind, Object.assign({ argument: argument, scope: scope, resolve: resolve, transform: transform, construct: construct }, callback(this.source)));
        }

        // ### validate (data, opts={})

        // Perform schema correctness validation for the passed in `data`.  This
        // differs from [eval](#eval-data-opts) in that the final data returned
        // is not infused as dynamic data model using Property instances. It
        // should be used to perform a sanity check on the data if it will not
        // be programmatically modified.

        // For example, [Property](./property.litcoffee) instance uses `validate`
        // when dealing with non-configurable data nodes `config false`. 

      }, {
        key: 'validate',
        value: function validate(data) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          return this.apply(data, null, Object.assign(opts, {
            force: true,
            preserve: true
          }));
        }

        // ### extends (schema...)

        // Every instance of `Yang` expression can be `extends` with additional
        // YANG schema string(s) and it will automatically perform
        // [parse](#parse-schema) of the provided schema text and update itself
        // accordingly.

        // This action also triggers an event emitter which will *retroactively*
        // adapt any previously [eval](#eval-data-opts) produced adaptive data
        // model instances to react accordingly to the newly changed underlying
        // schema expression(s).

        // extends() is inherited from Element

      }, {
        key: 'merge',
        value: function merge(elem, opts) {
          if (typeof elem === 'string') {
            elem = Yang.parse(elem);
          }
          if (!(elem instanceof Yang)) {
            throw this.error("cannot merge invalid element into Yang", elem);
          }
          switch (elem.kind) {
            case 'type':
              return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'merge', this).call(this, elem, {
                append: true
              });
            case 'argument':
              return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'merge', this).call(this, elem, {
                replace: true
              });
            default:
              return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'merge', this).call(this, elem, opts);
          }
        }

        // Please refer to [Schema Extension](../TUTORIAL.md#schema-extension)
        // section of the [Getting Started Guide](../TUTORIAL.md) for usage
        // examples.

      }, {
        key: 'normalizePath',
        value: function normalizePath(ypath) {
          var _this3 = this;

          var lastPrefix, normalizeEntry, prefix2module, res;
          lastPrefix = null;
          prefix2module = function prefix2module(root, prefix) {
            var i, j, len, len1, m, modules, ref, ref1;
            if (root.kind !== 'module') {
              return;
            }
            switch (false) {
              case root.tag !== prefix:
                return prefix;
              case root.prefix.tag !== prefix:
                return root.tag;
              default:
                ref1 = (ref = root.import) != null ? ref : [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  m = ref1[i];
                  if (m.tag === prefix || m.prefix.tag === prefix) {
                    return m.tag;
                  }
                }
                modules = root.lookup('module');
                for (j = 0, len1 = modules.length; j < len1; j++) {
                  m = modules[j];
                  if (m.tag === prefix || m.prefix.tag === prefix) {
                    return m.tag;
                  }
                }
                return prefix; // return as-is...
            }
          };
          normalizeEntry = function normalizeEntry(x) {
            var match, mname, prefix, target;
            if (!(x != null && !!x)) {
              return x;
            }
            match = x.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)(?:\[.+\])?$/);
            if (match == null) {
              throw _this3.error('invalid path expression \'' + x + '\' found in ' + ypath);
            }
            var _ref = [match[1], match[2]];
            prefix = _ref[0];
            target = _ref[1];

            switch (false) {
              case !(prefix == null):
                return target;
              case prefix !== lastPrefix:
                return target;
              default:
                lastPrefix = prefix;
                mname = prefix2module(_this3.root, prefix);
                return mname + ':' + target;
            }
          };
          ypath = ypath.replace(/\s/g, '');
          res = XPath.split(ypath).map(normalizeEntry).join('/');
          if (/^\//.test(ypath)) {
            res = '/' + res;
          }
          return res;
        }

        // ### locate (ypath)

        // This is an internal helper facility used to locate a given schema node
        // within the `Yang` schema expression tree hierarchy. It supports a
        // limited version of XPATH-like expression to locate an explicit
        // element.

      }, {
        key: 'locate',
        value: function locate(ypath) {
          var _ref4, _ref5, _splice$call, _splice$call2;

          var i, key, kind, len, m, match, prefix, ref, ref1, ref2, ref3, rest, search, selector, tag, target;
          // TODO: figure out how to eliminate duplicate code-block section
          // shared with Element
          if (ypath == null) {
            return;
          }
          this.debug(function () {
            return 'locate enter for \'' + ypath + '\'';
          });
          if (typeof ypath === 'string') {
            if (/^\//.test(ypath) && this !== this.root) {
              return this.root.locate(ypath);
            }

            var _normalizePath$split$ = this.normalizePath(ypath).split('/').filter(function (e) {
              return !!e;
            });

            var _normalizePath$split$2 = _toArray(_normalizePath$split$);

            key = _normalizePath$split$2[0];
            rest = _normalizePath$split$2.slice(1);
          } else {
            var _ypath = _toArray(ypath);

            key = _ypath[0];
            rest = _ypath.slice(1);
          }
          this.debug(function () {
            return key;
          });
          if (!(key != null && key !== '.')) {
            return this;
          }
          if (key === '..') {
            return (ref = this.parent) != null ? ref.locate(rest) : void 0;
          }
          match = key.match(/^(?:([._-\w]+):)?([.{[<\w][.,+_\-}():>\]\w]*)$/);
          var _ref2 = [match[1], match[2]];
          prefix = _ref2[0];
          target = _ref2[1];

          if (prefix != null && this === this.root) {
            search = [target].concat(rest);
            if (this.tag === prefix || this.lookup('prefix', prefix)) {
              this.debug(function () {
                return 'locate (local) \'/' + prefix + ':' + search.join('/') + '\'';
              });
              return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'locate', this).call(this, search);
            }
            ref2 = (ref1 = this.import) != null ? ref1 : [];
            for (i = 0, len = ref2.length; i < len; i++) {
              m = ref2[i];
              if (!(m.tag === prefix || m.prefix.tag === prefix)) {
                continue;
              }
              this.debug(function () {
                return 'locate (external) \'/' + prefix + ':' + search.join('/') + '\'';
              });
              return m.module.locate(search);
            }
            m = this.lookup('module', prefix);
            return m != null ? m.locate(search) : void 0;
          }
          this.debug(function () {
            return 'checking ' + target;
          });
          switch (false) {
            case !/^{.+}$/.test(target):
              kind = 'grouping';
              tag = target.replace(/^{(.+)}$/, '$1');
              break;
            case !/^\[.+\]$/.test(target):
              kind = 'feature';
              tag = target.replace(/^\[(.+)\]$/, '$1');
              break;
            case !/^[^(]+\([^)]*\)$/.test(target):
              target = target.match(/^([^(]+)\((.*)\)$/);
              var _ref3 = [target[1], target[2]];
              kind = _ref3[0];
              tag = _ref3[1];

              if (!tag) {
                tag = void 0;
              }
              break;
            case !/^\<.+\>$/.test(target):
              target = target.replace(/^\<(.+)\>$/, '$1');
              ref3 = target.split(':'), (_ref4 = ref3, _ref5 = _toArray(_ref4), kind = _ref5.slice(0), _ref4), (_splice$call = splice.call(kind, -1), _splice$call2 = _slicedToArray(_splice$call, 1), tag = _splice$call2[0], _splice$call);

              var _tag$split = tag.split('=');

              var _tag$split2 = _slicedToArray(_tag$split, 2);

              tag = _tag$split2[0];
              selector = _tag$split2[1];

              if (kind != null ? kind.length : void 0) {
                kind = kind[0];
              }
              break;
            default:
              return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'locate', this).call(this, [key].concat(rest));
          }
          this.debug(function () {
            return 'matching ' + kind + ' ' + tag;
          });
          match = this.match(kind, tag);
          switch (false) {
            case rest.length !== 0:
              return match;
            case !Array.isArray(match):
              return match.map(function (x) {
                return x.locate(rest);
              }).filter(Boolean);
            default:
              return match != null ? match.locate(rest) : void 0;
          }
        }

        // ### match (kind, tag)

        // This is an internal helper facility used by [locate](#locate-ypath) and
        // [lookup](./element.litcoffee#lookup-kind-tag) to test whether a given
        // entity exists in the local schema tree.

        // Yang Expression can support 'tag' with prefix to another module
        // (or itself).

      }, {
        key: 'match',
        value: function match(kind, tag) {
          var _ref6, _ref7, _splice$call3, _splice$call4;

          var arg, ctx, i, imports, len, m, module, prefix, ref, ref1, ref2, ref3, ref4, ref5, res;
          if (!(kind != null && tag != null && typeof tag === 'string')) {
            return _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'match', this).apply(this, arguments);
          }
          res = _get(Yang.prototype.__proto__ || Object.getPrototypeOf(Yang.prototype), 'match', this).apply(this, arguments);
          if (res != null) {
            return res;
          }
          ref = tag.split(':'), (_ref6 = ref, _ref7 = _toArray(_ref6), prefix = _ref7.slice(0), _ref6), (_splice$call3 = splice.call(prefix, -1), _splice$call4 = _slicedToArray(_splice$call3, 1), arg = _splice$call4[0], _splice$call3);
          if (!prefix.length) {
            return;
          }
          this.debug(function () {
            return '[match] with ' + kind + ' ' + tag;
          });
          prefix = prefix[0];
          this.debug(function () {
            return "[match] check if current module's prefix";
          });
          if (this.root.tag === prefix || ((ref1 = this.root.prefix) != null ? ref1.tag : void 0) === prefix) {
            return this.root.match(kind, arg);
          }
          this.debug(function () {
            return "[match] checking if submodule's parent";
          });
          ctx = this.lookup('belongs-to');
          if ((ctx != null ? ctx.prefix.tag : void 0) === prefix) {
            return (ref2 = ctx.module) != null ? ref2.match(kind, arg) : void 0;
          }
          this.debug(function () {
            return "[match] check if one of current module's imports";
          });
          imports = (ref3 = (ref4 = this.root) != null ? ref4.import : void 0) != null ? ref3 : [];
          for (i = 0, len = imports.length; i < len; i++) {
            m = imports[i];
            if (!(m.prefix.tag === prefix)) {
              continue;
            }
            this.debug(function () {
              return '[match] checking ' + m.tag;
            });
            return (ref5 = m.module) != null ? ref5.match(kind, arg) : void 0;
          }
          this.debug(function () {
            return "[match] check if one of available modules";
          });
          module = this.lookup('module', prefix);
          if (module != null) {
            return module.match(kind, arg);
          }
        }

        // ### toString (opts={})

        // The current `Yang` expression will covert back to the equivalent YANG
        // schema text format.

        // At first glance, this may not seem like a useful facility since YANG
        // schema text is *generally known* before [parse](#parse-schema) but it
        // becomes highly relevant when you consider a given `Yang` expression
        // programatically changing via [extends](#extends-schema).

        // Currently it supports `space` parameter which can be used to specify
        // number of spaces to use for indenting YANG statement blocks.  It
        // defaults to **2** but when set to **0**, the generated output will
        // omit newlines and other spacing for a more compact YANG output.

      }, {
        key: 'toString',
        value: function toString() {
          var _this4 = this;

          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            space: 2
          };

          var s, sub;
          s = this.kind;
          if (this.argument != null) {
            s += ' ' + function () {
              switch (this.argument) {
                case 'value':
                  switch (false) {
                    case !Array.isArray(this.tag):
                      return '\'' + this.tag.join(' ') + '\'';
                    default:
                      return '\'' + this.tag + '\'';
                  }
                  break;
                case 'text':
                  return "\n" + indent('"' + this.tag + '"', ' ', opts.space);
                default:
                  return this.tag;
              }
            }.call(this);
          }
          sub = this.children.filter(function (x) {
            return x.parent === _this4;
          }).map(function (x) {
            return x.toString(opts);
          }).join("\n");
          if (!!sub) {
            s += " {\n" + indent(sub, ' ', opts.space) + "\n}";
          } else {
            s += ';';
          }
          return s;
        }

        // ### toJSON

        // The current `Yang` expression will convert into a simple JS object
        // format.

        // toJSON() is inherited from Element

        // ### valueOf

        // The current 'Yang' expression will convert into a primitive form for
        // comparision purposes.

      }, {
        key: 'valueOf',
        value: function valueOf() {
          switch (this.argument) {
            case 'value':
            case 'text':
              return this.tag.valueOf();
            default:
              return this;
          }
        }
      }], [{
        key: 'clear',

        // ## Class-level methods
        value: function clear() {
          if (this.module != null) {
            this.module.splice(0, this.module.length);
          }
          if (this.submodule != null) {
            return this.submodule.splice(0, this.submodule.length);
          }
        }

        // ### parse (schema)

        // This class-level routine performs recursive parsing of passed in
        // statement and sub-statements. It provides syntactic, semantic and
        // contextual validations on the provided schema and returns the final JS
        // object tree structure as hierarchical Yang expression instances.

        // If any validation errors are encountered, it will throw the
        // appropriate error along with the context information regarding the
        // error.

      }, {
        key: 'parse',
        value: function parse(schema) {
          var _this5 = this;

          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var constraint, e, kind, offender, ref, tag, yang;
          if (schema instanceof Yang) {
            return schema;
          }
          if (opts.compile == null) {
            opts.compile = true;
          }
          try {
            if (typeof schema === 'string') {
              schema = parser.parse(schema);
            }
          } catch (error) {
            e = error;
            if (!(e.offset > 50)) {
              e.offset = 50;
            }
            offender = schema.slice(e.offset - 50, e.offset + 50);
            offender = offender.replace(/\s\s+/g, ' ');
            throw this.error('invalid YANG syntax detected around: \'' + offender + '\'', offender);
          }
          if (!(schema instanceof Object)) {
            throw this.error("must pass in valid YANG schema", schema);
          }
          kind = function () {
            switch (false) {
              case !schema.prf:
                return schema.prf + ':' + schema.kw;
              default:
                return schema.kw;
            }
          }();
          if (schema.arg !== false) {
            tag = schema.arg;
          }
          yang = new this(kind, tag).extends(schema.substmts.map(function (x) {
            return _this5.parse(x, {
              compile: x.kw === 'extension'
            });
          }));
          ref = yang.scope;

          // perform final scoped constraint validation
          for (kind in ref) {
            constraint = ref[kind];
            if (constraint === '1' || constraint === '1..n') {
              if (!yang.hasOwnProperty(kind)) {
                throw yang.error('constraint violation for required \'' + kind + '\' = ' + constraint);
              }
            }
          }
          if (opts.compile) {
            yang.compile();
          }
          return yang;
        }

        // For comprehensive overview on currently supported YANG statements,
        // please refer to
        // [Compliance Report](../test/yang-compliance-coverage.md) for the latest
        // [RFC 6020](http://tools.ietf.org/html/rfc6020) YANG specification
        // compliance.

        // ### compose (data [, opts={}])

        // This call *accepts* any arbitrary JS object and it will attempt to
        // convert it into a structural `Yang` expression instance. It will
        // analyze the passed in JS data and perform best match mapping to an
        // appropriate YANG schema representation to describe the input
        // data. This method will not be able to determine conditionals or any
        // meta-data to further constrain the data, but it should provide a good
        // starting point with the resulting `Yang` expression instance.

      }, {
        key: 'compose',
        value: function compose(data) {
          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var ext, i, len, ref, res;
          if (data == null) {
            throw this.error("must supply input 'data' to compose");
          }
          // explict compose
          if (opts.kind != null) {
            ext = Yang.prototype.lookup.call(this, 'extension', opts.kind);
            if (!(ext instanceof Expression)) {
              throw this.error('unable to find requested \'' + opts.kind + '\' extension');
            }
            return typeof ext.compose === "function" ? ext.compose(data, opts) : void 0;
          }
          ref = this.extension;
          // implicit compose (dynamic discovery)
          for (i = 0, len = ref.length; i < len; i++) {
            ext = ref[i];
            if (!(ext.compose instanceof Function)) {
              continue;
            }
            debug('checking data if ' + ext.tag);
            res = ext.compose(data, opts);
            if (res instanceof Yang) {
              return res;
            }
          }
        }
      }]);

      return Yang;
    }(Expression);

    ;

    Yang.prototype.logger = require('debug')('yang:schema');

    Yang.scope = {
      extension: '0..n',
      typedef: '0..n',
      module: '0..n',
      submodule: '0..n'
    };

    // This facility is a powerful construct to dynamically generate `Yang`
    // schema from ordinary JS objects. For additional usage examples, please
    // refer to [Dynamic Composition](../TUTORIAL.md#dynamic-composition)
    // section in the [Getting Started Guide](../TUTORIAL.md).

    // ## Main constructor

    // The constructor inherits from `Expression` which returns a `bound
    // function` that invokes [eval](#eval-data-opts) when called.
    Yang.property('source', {
      get: function get() {
        var base;
        if ((base = this.state).source == null) {
          base.source = this.lookup('extension', this.kind);
        }
        return this.state.source || {};
      },
      set: function set(value) {
        return this.state.source = value;
      }
    });

    Yang.property('datakey', {
      get: function get() {
        var ref;
        switch (false) {
          case !(this.parent instanceof Yang && this.parent.kind === 'module'):
            return this.parent.tag + ':' + this.tag;
          case !(this.parent instanceof Yang && this.parent.kind === 'submodule'):
            return this.parent['belongs-to'].tag + ':' + this.tag;
          case !(this.node && this.external && !this.state.relative):
            return this.origin.root.tag + ':' + this.tag;
          default:
            return (ref = this.tag) != null ? ref : this.kind;
        }
      }
    });

    Yang.property('external', {
      get: function get() {
        return this.origin != null && this.origin.root !== this.root && this.origin.root.kind === 'module';
      }
    });

    Yang.property('datapath', {
      get: function get() {
        var label, ref;
        if (this.kind === 'module') {
          return '';
        }
        label = this.node ? this.datakey : this.kind + '(' + this.datakey + ')';
        switch (false) {
          case ((ref = this.parent) != null ? ref.datapath : void 0) == null:
            return [this.parent.datapath, label].join('/');
          default:
            return label;
        }
      }
    });

    return Yang;
  }.call(this);

  // Please refer to [Schema Conversion](../TUTORIAL.md#schema-conversion)
  // section of the [Getting Started Guide](../TUTORIAL.md) for usage
  // examples.

  // ## Export Yang Class
  module.exports = Yang;
}).call(undefined);

},{"./expression":4,"./extension":5,"./xpath":17,"debug":25,"indent-string":29,"yang-parser":38}],19:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":33,"util/":22}],20:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],21:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],22:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":21,"_process":34,"inherits":20}],23:[function(require,module,exports){

},{}],24:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var Parser,
    __slice = [].slice;

  Parser = (function() {
    function Parser(pf) {
      this.pf = pf;
    }

    Parser.prototype.parse = function(text) {
      var res;
      Parser.prototype._text = text;
      res = this.pf(0);
      if (res[0] === null) {
        throw Parser.error("Parsing failed", res[1]);
      }
      return res[0];
    };

    Parser.unit = function(v) {
      return new Parser(function(offset) {
        return [v, offset];
      });
    };

    Parser.prototype.bind = function(f) {
      return new Parser((function(_this) {
        return function(offset) {
          var res;
          res = _this.pf(offset);
          if (res[0] === null) {
            return [null, res[1]];
          } else {
            return (f(res[0])).pf(res[1]);
          }
        };
      })(this));
    };

    Parser.prototype.orElse = function(other) {
      return new Parser((function(_this) {
        return function(offset) {
          var res;
          res = _this.pf(offset);
          if (res[0] === null) {
            return other.pf(offset);
          } else {
            return res;
          }
        };
      })(this));
    };

    Parser.choice = function() {
      var p, q;
      p = arguments[0], q = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (q.length === 0) {
        return p;
      } else {
        return p.orElse(Parser.choice.apply(null, q));
      }
    };

    Parser.prototype.many = function(min) {
      if (min == null) {
        min = 0;
      }
      return new Parser((function(_this) {
        return function(offset) {
          var npt, pt, res, val, _ref;
          res = [];
          pt = offset;
          while (true) {
            _ref = _this.pf(pt), val = _ref[0], npt = _ref[1];
            if (val === null) {
              break;
            }
            res.push(val);
            pt = npt;
          }
          if (res.length < min) {
            return [null, npt];
          } else {
            return [res, pt];
          }
        };
      })(this));
    };

    Parser.prototype.concat = function(min) {
      return this.many(min).bind(function(arr) {
        return Parser.unit(arr.join(''));
      });
    };

    Parser.prototype.skipMany = function(min) {
      if (min == null) {
        min = 0;
      }
      return new Parser((function(_this) {
        return function(offset) {
          var cnt, npt, pt, val, _ref;
          cnt = 0;
          pt = offset;
          while (true) {
            _ref = _this.pf(pt), val = _ref[0], npt = _ref[1];
            if (val === null) {
              break;
            }
            cnt++;
            pt = npt;
          }
          if (cnt < min) {
            return [null, npt];
          } else {
            return [cnt, pt];
          }
        };
      })(this));
    };

    Parser.prototype.manyTill = function(end) {
      return new Parser((function(_this) {
        return function(offset) {
          var npt, pt, res, val, _ref, _ref1;
          res = [];
          pt = offset;
          while (true) {
            _ref = end.pf(pt), val = _ref[0], npt = _ref[1];
            if (val !== null) {
              return [res, npt];
            }
            _ref1 = _this.pf(pt), val = _ref1[0], pt = _ref1[1];
            if (val === null) {
              return [null, pt];
            }
            res.push(val);
          }
        };
      })(this));
    };

    Parser.prototype.repeat = function(count) {
      if (count == null) {
        count = 2;
      }
      if (count <= 0) {
        return Parser.unit([]);
      } else {
        return this.bind((function(_this) {
          return function(head) {
            return _this.repeat(count - 1).bind(function(tail) {
              tail.unshift(head);
              return Parser.unit(tail);
            });
          };
        })(this));
      }
    };

    Parser.prototype.between = function(lft, rt) {
      return lft.bind((function(_this) {
        return function() {
          return _this.bind(function(res) {
            return rt.bind(function() {
              return Parser.unit(res);
            });
          });
        };
      })(this));
    };

    Parser.prototype.option = function(dflt) {
      if (dflt == null) {
        dflt = '';
      }
      return this.orElse(Parser.unit(dflt));
    };

    Parser.prototype.sepBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      if (min === 0) {
        return this.sepBy(sep, 1).orElse(Parser.unit([]));
      } else {
        return this.bind((function(_this) {
          return function(head) {
            return (sep.bind(function() {
              return _this;
            })).many(min - 1).bind(function(tail) {
              tail.unshift(head);
              return Parser.unit(tail);
            });
          };
        })(this));
      }
    };

    Parser.prototype.endBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      return (this.bind(function(x) {
        return sep.bind(function() {
          return Parser.unit(x);
        });
      })).many(min);
    };

    Parser.prototype.sepEndBy = function(sep, min) {
      if (min == null) {
        min = 0;
      }
      return this.sepBy(sep, min).bind(function(res) {
        return sep.option().bind(function() {
          return Parser.unit(res);
        });
      });
    };

    Parser.prototype.notFollowedBy = function(p) {
      return this.bind(function(res) {
        return new Parser(function(offset) {
          var val;
          val = (p.pf(offset))[0] === null ? res : null;
          return [val, offset];
        });
      });
    };

    Parser.eof = new Parser(function(offset) {
      var res;
      res = offset >= this._text.length ? true : null;
      return [res, offset];
    });

    Parser.anyChar = new Parser(function(offset) {
      var next;
      next = this._text[offset++];
      if (next != null) {
        return [next, offset];
      } else {
        return [null, offset];
      }
    });

    Parser.sat = function(pred) {
      return Parser.anyChar.bind(function(x) {
        if (pred(x)) {
          return Parser.unit(x);
        } else {
          return new Parser(function(offset) {
            return [null, offset - 1];
          });
        }
      });
    };

    Parser.char = function(ch) {
      return Parser.sat(function(x) {
        return ch === x;
      });
    };

    Parser.oneOf = function(alts) {
      return Parser.sat(function(x) {
        return alts.indexOf(x) >= 0;
      });
    };

    Parser.noneOf = function(alts) {
      return Parser.sat(function(x) {
        return alts.indexOf(x) === -1;
      });
    };

    Parser.lower = Parser.sat(function(x) {
      return /^[a-z]$/.test(x);
    });

    Parser.upper = Parser.sat(function(x) {
      return /^[A-Z]$/.test(x);
    });

    Parser.alphanum = Parser.sat(function(x) {
      return /^\w$/.test(x);
    });

    Parser.space = Parser.sat(function(x) {
      return /^\s$/.test(x);
    });

    Parser.digit = Parser.oneOf('0123456789');

    Parser.octDigit = Parser.oneOf('01234567');

    Parser.hexDigit = Parser.oneOf('01234567abcdefABCDEF');

    Parser.nat0 = Parser.digit.concat(1).bind(function(ds) {
      return Parser.unit(Number(ds));
    });

    Parser.letter = Parser.lower.orElse(Parser.upper);

    Parser.skipSpace = Parser.space.skipMany();

    Parser.string = function(str) {
      return new Parser(function(offset) {
        if (str === this._text.substr(offset, str.length)) {
          return [str, offset + str.length];
        } else {
          return [null, offset];
        }
      });
    };

    Parser.offset = new Parser(function(offset) {
      return [offset, offset];
    });

    Parser.offset2coords = function(offset, tab) {
      var beg, expTab, lf, ln;
      if (tab == null) {
        tab = 8;
      }
      expTab = function(from, to) {
        var c, cnt, _i, _len, _ref;
        cnt = 0;
        _ref = Parser.prototype._text.slice(from, to);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          cnt += c === '\t' ? tab : 1;
        }
        return cnt;
      };
      ln = 1;
      beg = 0;
      while (true) {
        lf = Parser.prototype._text.indexOf('\n', beg);
        if (lf === -1 || lf >= offset) {
          break;
        }
        ln += 1;
        beg = lf + 1;
      }
      return [ln, expTab(beg, offset)];
    };

    Parser.coordinates = new Parser(function(offset) {
      return [Parser.offset2coords(offset), offset];
    });

    Parser.error = function(msg, offset) {
      var res;
      res = new Error(msg);
      res.name = 'ParsingError';
      res.offset = offset;
      res.coords = this.offset2coords(offset);
      return res;
    };

    return Parser;

  })();

  if (module.exports != null) {
    module.exports = Parser;
  } else {
    this.Parser = Parser;
  }

}).call(this);

},{}],25:[function(require,module,exports){
(function (process){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this,require('_process'))
},{"./common":26,"_process":34}],26:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":32}],27:[function(require,module,exports){

/**
 * Expose `Delegator`.
 */

module.exports = Delegator;

/**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */

function Delegator(proto, target) {
  if (!(this instanceof Delegator)) return new Delegator(proto, target);
  this.proto = proto;
  this.target = target;
  this.methods = [];
  this.getters = [];
  this.setters = [];
  this.fluents = [];
}

/**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.method = function(name){
  var proto = this.proto;
  var target = this.target;
  this.methods.push(name);

  proto[name] = function(){
    return this[target][name].apply(this[target], arguments);
  };

  return this;
};

/**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.access = function(name){
  return this.getter(name).setter(name);
};

/**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.getter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.getters.push(name);

  proto.__defineGetter__(name, function(){
    return this[target][name];
  });

  return this;
};

/**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.setter = function(name){
  var proto = this.proto;
  var target = this.target;
  this.setters.push(name);

  proto.__defineSetter__(name, function(val){
    return this[target][name] = val;
  });

  return this;
};

/**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */

Delegator.prototype.fluent = function (name) {
  var proto = this.proto;
  var target = this.target;
  this.fluents.push(name);

  proto[name] = function(val){
    if ('undefined' != typeof val) {
      this[target][name] = val;
      return this;
    } else {
      return this[target][name];
    }
  };

  return this;
};

},{}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],29:[function(require,module,exports){
'use strict';
var repeating = require('repeating');

module.exports = function (str, indent, count) {
	if (typeof str !== 'string' || typeof indent !== 'string') {
		throw new TypeError('`string` and `indent` should be strings');
	}

	if (count != null && typeof count !== 'number') {
		throw new TypeError('`count` should be a number');
	}

	if (count === 0) {
		return str;
	}

	indent = count > 1 ? repeating(indent, count) : indent;

	return str.replace(/^(?!\s*$)/mg, indent);
};

},{"repeating":35}],30:[function(require,module,exports){
'use strict';

module.exports = Number.isFinite || function (value) {
	return !(typeof value !== 'number' || value !== value || value === Infinity || value === -Infinity);
};

},{}],31:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],33:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],34:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],35:[function(require,module,exports){
'use strict';
var isFinite = require('is-finite');

module.exports = function (str, n) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected `input` to be a string');
	}

	if (n < 0 || !isFinite(n)) {
		throw new TypeError('Expected `count` to be a positive finite number');
	}

	var ret = '';

	do {
		if (n & 1) {
			ret += str;
		}

		str += str;
	} while ((n >>= 1));

	return ret;
};

},{"is-finite":30}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

exports.parse = parse;

},{}],37:[function(require,module,exports){
// Generated by CoffeeScript 1.12.2
(function() {
  var ExpressionParser, P, argument, combine, divide, equal, evaluate, exports, expr, factor, factory, gt, gte, lt, lte, method, minus, modulo, multiply, negate, number, operators, opf, optSep, plus, quote, sep, term1, term2, term3, term4, term5, union, variable, wrap, xparse,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  P = require('comparse');

  sep = P.space.skipMany(1);

  optSep = P.space.skipMany();

  P.prototype.within = function(p) {
    return this.between(p, p);
  };

  number = P.char('-').option('').bind(function(neg) {
    return P.digit.concat(1).bind(function(head) {
      return (P.char('.').bind(function(dot) {
        return P.digit.concat(1).bind(function(tail) {
          return P.unit(Number(neg + head + dot + tail));
        });
      })).orElse(P.unit(Number(neg + head)));
    });
  });

  variable = (P.letter.orElse(P.char('_'))).bind(function(fst) {
    return P.alphanum.concat().bind(function(rest) {
      return P.unit(fst + rest);
    });
  });

  quote = P.noneOf("'").concat().between(P.char("'"), P.char("'"));

  argument = P.choice(variable, quote, number).between(optSep, optSep);

  method = variable.bind(function(name) {
    return P.char('(').bind(function() {
      return argument.option().bind(function(arg) {
        return P.char(')').bind(function() {
          return P.unit([name, arg]);
        });
      });
    });
  });

  operators = {
    '*': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x * y;
    },
    '/': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x / y;
    },
    '%': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x % y;
    },
    '+': function(x, y) {
      if (y == null) {
        y = 0;
      }
      return x + y;
    },
    '-': function(x, y) {
      if (y == null) {
        y = 0;
      }
      return x - y;
    },
    '<': function(x, y) {
      return x < y;
    },
    '<=': function(x, y) {
      return x <= y;
    },
    '>': function(x, y) {
      return x > y;
    },
    '>=': function(x, y) {
      return x >= y;
    },
    '=': function(x, y) {
      return x === y;
    },
    '==': function(x, y) {
      return x === y;
    },
    'div': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x / y;
    },
    'mod': function(x, y) {
      if (y == null) {
        y = 1;
      }
      return x % y;
    },
    'or': function(x, y) {
      return Boolean(x || y);
    },
    '||': function(x, y) {
      return Boolean(x || y);
    },
    'and': function(x, y) {
      return Boolean(x && y);
    },
    '&&': function(x, y) {
      return Boolean(x && y);
    },
    '!': function(x) {
      return !x;
    },
    'not': function(x) {
      return !x;
    }
  };

  opf = function(op) {
    return P.unit(operators[op]);
  };

  multiply = P.char('*').within(optSep).bind(opf);

  divide = (P.char('/').within(optSep).orElse(P.string('div').within(sep))).bind(opf);

  modulo = (P.char('%').within(optSep).orElse(P.string('mod').within(sep))).bind(opf);

  plus = P.char('+').within(optSep).bind(opf);

  minus = P.char('-').within(optSep).bind(opf);

  lt = P.char('<').within(optSep).bind(opf);

  lte = P.string('<=').within(optSep).bind(opf);

  gt = P.char('>').within(optSep).bind(opf);

  gte = P.string('>=').within(optSep).bind(opf);

  equal = (P.string('==').within(optSep).orElse(P.char('=').within(optSep))).bind(opf);

  negate = (P.char('!').orElse(P.string('not').between(optSep, sep))).bind(opf);

  union = (P.char('|').concat(2).within(optSep).orElse(P.string('or').within(sep))).bind(opf);

  combine = (P.char('&').concat(2).within(optSep).orElse(P.string('and').within(sep))).bind(opf);

  evaluate = function(x, y, resolver) {
    var ref;
    x = typeof x === 'function' ? x(resolver) : x;
    y = typeof y === 'function' ? y(resolver) : y;
    return (ref = typeof this === "function" ? this(x, y) : void 0) != null ? ref : typeof resolver === "function" ? resolver(x, y) : void 0;
  };

  wrap = function(func, x, y) {
    var f, k, kind, v;
    if (y == null) {
      y = null;
    }
    kind = (function() {
      switch (false) {
        case func == null:
          return x + " " + func.name + " " + y;
        case !((x != null) && (y != null)):
          return x + "(" + y + ")";
        case x == null:
          return "" + x;
      }
    })();
    f = evaluate.bind(func, x, y);
    for (k in arguments) {
      v = arguments[k];
      f[k] = v;
    }
    Object.defineProperty(f, 'toString', {
      value: function() {
        return kind;
      }
    });
    return P.unit(f);
  };

  P.prototype.step = function(before, after) {
    return before().bind((function(_this) {
      return function(x) {
        var next;
        next = _this.bind(function(op) {
          return after().bind(function(y) {
            return wrap(op, x, y);
          });
        });
        return next.option(x);
      };
    })(this));
  };

  expr = function() {
    return union.step(term1, expr);
  };

  term1 = function() {
    return combine.step(term2, term1);
  };

  term2 = function() {
    return equal.step(term3, term2);
  };

  term3 = function() {
    return P.choice(lt, lte, gt, gte).step(term4, term3);
  };

  term4 = function() {
    return P.choice(plus, minus).step(term5, term4);
  };

  term5 = function() {
    return P.choice(multiply, divide, modulo).step(factor, term5);
  };

  factor = function() {
    return P.choice(negate.bind(function(op) {
      return factor().bind(function(f) {
        return wrap(op, f);
      });
    }), P.char('(').bind(function() {
      return optSep.bind(function() {
        return expr().bind(function(e) {
          return optSep.bind(function() {
            return P.char(')').bind(function() {
              return P.unit(e);
            });
          });
        });
      });
    }), method.bind(function(kv) {
      if (kv == null) {
        kv = [];
      }
      return wrap(null, kv[0], kv[1]);
    }), variable.bind(function(k) {
      return wrap(null, k);
    }), number, quote);
  };

  factory = function(f) {
    var p;
    p = f();
    return p.parse.bind(p);
  };

  xparse = factory(function() {
    return expr().within(optSep);
  });

  exports = module.exports = xparse['default'] = xparse;

  exports.Parser = ExpressionParser = (function(superClass) {
    extend(ExpressionParser, superClass);

    function ExpressionParser() {
      return ExpressionParser.__super__.constructor.apply(this, arguments);
    }

    ExpressionParser.create = factory;

    ExpressionParser.wrap = wrap;

    ExpressionParser.number = number;

    ExpressionParser.variable = variable;

    ExpressionParser.quote = quote;

    ExpressionParser.argument = argument;

    ExpressionParser.method = method;

    ExpressionParser.operators = operators;

    ExpressionParser.multiply = multiply;

    ExpressionParser.divide = divide;

    ExpressionParser.modulo = modulo;

    ExpressionParser.plus = plus;

    ExpressionParser.minus = minus;

    ExpressionParser.lt = lt;

    ExpressionParser.lte = lte;

    ExpressionParser.gt = gt;

    ExpressionParser.gte = gte;

    ExpressionParser.equal = equal;

    ExpressionParser.negate = negate;

    ExpressionParser.union = union;

    ExpressionParser.combine = combine;

    return ExpressionParser;

  })(P);

}).call(this);

},{"comparse":24}],38:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
(function() {
  var P, YangStatement, argument, blockComment, comment, dqChar, dqLit, dqString, escape, fallback, identifier, keyword, lineComment, optSep, parse, qArg, semiOrBlock, sep, sqLit, statement, stmtBlock, strict, uArg;

  P = require('comparse');

  YangStatement = (function() {
    function YangStatement(prf, kw, arg, substmts) {
      this.prf = prf;
      this.kw = kw;
      this.arg = arg;
      this.substmts = substmts;
    }

    return YangStatement;

  })();

  lineComment = (P.string('//')).bind(function() {
    return P.anyChar.manyTill(P.char('\n')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  blockComment = (P.string('/*')).bind(function() {
    return P.anyChar.manyTill(P.string('*/')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  comment = lineComment.orElse(blockComment);

  sep = (P.space.orElse(comment)).skipMany(1);

  optSep = (P.space.orElse(comment)).skipMany();

  identifier = (P.letter.orElse(P.char('_'))).bind(function(fst) {
    return (P.alphanum.orElse(P.oneOf('.-'))).many().bind(function(tail) {
      var res;
      res = fst + tail.join('');
      return P.unit(res.slice(0, 3).toLowerCase() === 'xml' ? null : res);
    });
  });

  keyword = (identifier.bind(function(prf) {
    return P.char(':').bind(function() {
      return P.unit(prf);
    });
  })).option().bind(function(pon) {
    return identifier.bind(function(kw) {
      return P.unit([pon, kw]);
    });
  });

  uArg = (P.noneOf(" '\"\n\t\r;{}/").orElse(P.char('/').notFollowedBy(P.oneOf('/*')))).concat(1);

  sqLit = P.sat(function(c) {
    return c !== "'";
  }).concat().between(P.char("'"), P.char("'"));

  escape = P.char('\\').bind(function() {
    var esc;
    esc = {
      't': '\t',
      'n': '\n',
      '"': '"',
      '\\': '\\'
    };
    return P.oneOf('tn"\\').bind(function(c) {
      return P.unit(esc[c]);
    }).orElse(fallback);
  });

  strict = false;

  fallback = P.anyChar.bind(function(c) {
    return P.unit(strict ? null : "\\" + c);
  });

  dqChar = P.noneOf('"\\').orElse(escape);

  dqLit = P.char('"').bind(function() {
    return P.coordinates.bind(function(col) {
      return dqString(col[1]);
    });
  });

  dqString = function(lim) {
    var trimLead;
    trimLead = function(str) {
      var c, i, left, sptab;
      left = lim;
      sptab = '        ';
      i = 0;
      while (left > 0) {
        c = str[i++];
        if (c === ' ') {
          left -= 1;
        } else if (c === '\t') {
          if (left < 8) {
            return sptab.slice(0, 8 - left) + str.slice(i);
          }
          left -= 8;
        } else {
          return str.slice(i - 1);
        }
      }
      return str.slice(i);
    };
    return dqChar.manyTill(P.char('"')).bind(function(cs) {
      var lines, ln, mo, res, tlines, _i, _j, _len, _len1, _ref, _ref1;
      lines = cs.join('').split('\n');
      tlines = [lines[0]];
      _ref = lines.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ln = _ref[_i];
        tlines.push(trimLead(ln));
      }
      res = [];
      _ref1 = tlines.slice(0, -1);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ln = _ref1[_j];
        mo = ln.match(/(.*\S)?\s*/);
        res.push(mo[1]);
      }
      res.push(tlines.pop());
      return P.unit(res.join('\n'));
    });
  };

  qArg = dqLit.orElse(sqLit).bind(function(lft) {
    return (P.char('+').between(optSep, optSep).bind(function() {
      return qArg;
    })).option().bind(function(rt) {
      return P.unit(lft + rt);
    });
  });

  argument = uArg.orElse(qArg);

  statement = keyword.bind(function(kw) {
    return (sep.bind(function() {
      return argument;
    })).option(false).bind(function(arg) {
      if (kw[1] === 'yang-version' && arg === '1.1') {
        strict = true;
      }
      return optSep.bind(function() {
        return semiOrBlock.bind(function(sst) {
          return P.unit(new YangStatement(kw[0], kw[1], arg, sst));
        });
      });
    });
  });

  stmtBlock = P.char('{').bind(function() {
    return (optSep.bind(function() {
      return statement;
    })).manyTill(optSep.bind(function() {
      return P.char('}');
    }));
  });

  semiOrBlock = (P.char(';').bind(function() {
    return P.unit([]);
  })).orElse(stmtBlock);

  parse = function(text, top) {
    var yst;
    if (top == null) {
      top = null;
    }
    yst = statement.between(optSep, optSep).parse(text);
    if ((top != null) && yst.kw !== top) {
      throw P.error("Wrong top-level statement", 0);
    }
    return yst;
  };

  module.exports = {
    parse: parse
  };

}).call(this);

},{"comparse":24}],39:[function(require,module,exports){
(function (global){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _require = require('./lib'),
    Yang = _require.Yang,
    Store = _require.Store,
    Model = _require.Model,
    Container = _require.Container,
    Property = _require.Property;

// initialize with YANG 1.1 extensions and typedefs


Yang.use(require('./lib/lang/extensions'));
Yang.use(require('./lib/lang/typedefs'));

var parseYangSchema = function parseYangSchema() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _args$flat = args.flat(),
      _args$flat2 = _slicedToArray(_args$flat, 2),
      schema = _args$flat2[0],
      spec = _args$flat2[1];

  return Yang.parse(schema).bind(spec);
};

exports = Yang;
exports.yang = parseYangSchema;
exports.Yang = Yang;
exports.Store = Store;
exports.Model = Model;
exports.Container = Container;
exports.Property = Property;

module.exports = global.Yang = exports;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib":6,"./lib/lang/extensions":8,"./lib/lang/typedefs":9}]},{},[39]);
